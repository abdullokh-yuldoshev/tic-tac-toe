<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Tic-Tac-Toe+</title>

  <!-- Force refresh / reduce caching (useful for Telegram WebView too) -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <style>
    :root{
      --teal1:#33d1cf;
      --teal2:#14b8b1;
      --teal3:#0aa6a1;

      --bg:#eef6f7;
      --bg2:#e9f2f3;

      --card:#f7fbfc;
      --card2:#ffffff;

      --text:#0f172a;
      --muted:#6b7280;
      --line:rgba(15,23,42,.10);

      --shadow: 0 18px 50px rgba(0,0,0,.14);
      --shadowSoft: 0 14px 36px rgba(0,0,0,.10);

      --pill:#0f2d31;
      --pillText:#d8f7f6;

      --btn:#21c7c4;
      --btnText:#ffffff;

      --chip:#eef6f7;
      --chipText:#0f172a;

      --focus: rgba(33,199,196,.35);

      --radiusXL: 26px;
      --radiusL: 18px;
      --radiusM: 14px;
      --radiusS: 12px;

      --gridGap: 8px;
      --cellSize: 40px;
      --cellRadius: 14px;

      --safeTop: env(safe-area-inset-top, 0px);
      --safeBottom: env(safe-area-inset-bottom, 0px);

      --textureOpacity: .08;
    }

    /* Dark theme overrides */
    html[data-theme="dark"], body[data-theme="dark"]{
      --bg:#06161a;
      --bg2:#071a1f;

      --card:#0b2328;
      --card2:#0c262c;

      --text:#eaf7f7;
      --muted:rgba(234,247,247,.65);
      --line:rgba(234,247,247,.12);

      --shadow: 0 22px 60px rgba(0,0,0,.50);
      --shadowSoft: 0 18px 46px rgba(0,0,0,.40);

      --chip:#0a2126;
      --chipText:#eaf7f7;

      --pill:#0a2126;
      --pillText:#eaf7f7;

      --textureOpacity: .10;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      overflow-x:hidden;
    }

    /* Background glow + subtle texture */
    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:-2;
      background:
        radial-gradient(900px 600px at 75% -10%, rgba(34,199,199,.24), rgba(0,0,0,0) 60%),
        radial-gradient(800px 600px at -10% 25%, rgba(16,168,168,.18), rgba(0,0,0,0) 62%),
        radial-gradient(1000px 700px at 50% 115%, rgba(0,0,0,.12), rgba(0,0,0,0) 62%);
      opacity:1;
    }

    /* subtle repeating texture (CSS-only, no images) */
    body::after{
      content:"";
      position:fixed;
      inset:-20px;
      pointer-events:none;
      z-index:-1;
      opacity: var(--textureOpacity);
      background:
        linear-gradient(135deg, rgba(255,255,255,.18) 0%, rgba(255,255,255,0) 55%),
        repeating-linear-gradient(90deg, rgba(0,0,0,.18) 0 1px, rgba(0,0,0,0) 1px 10px),
        repeating-linear-gradient(0deg, rgba(0,0,0,.10) 0 1px, rgba(0,0,0,0) 1px 12px);
      mix-blend-mode: overlay;
      filter: blur(.2px);
      transform: translateZ(0);
    }

    /* App frame */
    .app{
      min-height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding: calc(18px + var(--safeTop)) 16px calc(96px + var(--safeBottom));
      gap: 16px;
    }

    /* Centered page container */
    .pageWrap{
      width:min(520px, 100%);
      display:flex;
      flex-direction:column;
      gap: 14px;
      align-items:center;
    }

    /* Top chips (logo / version) */
    .topChips{
      width:min(520px, 100%);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 14px;
      border-radius: 999px;
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.94);
      box-shadow: 0 12px 30px rgba(0,0,0,.18);
      backdrop-filter: blur(10px);
    }
    html[data-theme="dark"] .chip, body[data-theme="dark"] .chip{
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.95);
    }
    .chipLogo{
      width:34px;height:34px;border-radius:999px;
      background: rgba(255,255,255,.20);
      display:grid;place-items:center;
      font-weight:800;
      letter-spacing:.5px;
    }
    .chipText{
      display:flex;
      flex-direction:column;
      line-height:1.1;
    }
    .chipText b{font-size:14px}
    .chipText small{font-size:11px; opacity:.8}

    /* Main teal header card (Home) */
    .hero{
      width:100%;
      border-radius: var(--radiusXL);
      padding: 18px 18px 16px;
      background:
        radial-gradient(180px 180px at 90% 25%, rgba(255,255,255,.22), rgba(255,255,255,0) 60%),
        radial-gradient(220px 220px at 65% 5%, rgba(255,255,255,.18), rgba(255,255,255,0) 62%),
        linear-gradient(135deg, var(--teal1), var(--teal2) 52%, var(--teal3));
      color:#fff;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .hero::after{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(260px 260px at 88% 40%, rgba(255,255,255,.18), rgba(255,255,255,0) 68%),
        radial-gradient(180px 180px at 98% 10%, rgba(255,255,255,.16), rgba(255,255,255,0) 70%);
      opacity:.9;
    }
    .heroInner{position:relative; z-index:1}
    .heroTitle{
      font-size: 28px;
      font-weight: 900;
      margin: 2px 0 6px;
      letter-spacing:-.4px;
    }
    .heroSub{
      font-size: 14px;
      opacity:.92;
      margin:0 0 12px;
      line-height:1.25;
    }
    .heroBtns{
      display:flex;
      gap: 12px;
      flex-wrap:wrap;
    }

    .btn{
      border:none;
      outline:none;
      cursor:pointer;
      border-radius: 999px;
      padding: 12px 16px;
      font-weight: 800;
      font-size: 14px;
      display:inline-flex;
      align-items:center;
      gap: 10px;
      transition: transform .08s ease, box-shadow .12s ease, opacity .12s ease, background .12s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:active{transform: translateY(1px)}
    .btnPrimary{
      background: rgba(255,255,255,.20);
      color:#fff;
      box-shadow: 0 12px 26px rgba(0,0,0,.16);
      backdrop-filter: blur(10px);
    }
    .btnPrimary:hover{opacity:.95}
    .btnGhost{
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.92);
      box-shadow: 0 12px 26px rgba(0,0,0,.14);
      backdrop-filter: blur(10px);
    }
    .btnGhost[disabled]{
      opacity:.55; cursor:not-allowed;
      transform:none;
    }

    .btnSolid{
      background: var(--btn);
      color: var(--btnText);
      box-shadow: 0 14px 34px rgba(0,0,0,.14);
    }
    .btnSoft{
      background: var(--card2);
      color: var(--text);
      border: 1px solid var(--line);
      box-shadow: 0 10px 22px rgba(0,0,0,.08);
    }

    /* Settings card */
    .card{
      width:100%;
      border-radius: 22px;
      background: var(--card2);
      border: 1px solid var(--line);
      box-shadow: var(--shadowSoft);
      padding: 16px;
    }

    .cardHeader{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
      margin-bottom: 10px;
    }
    .cardHeader h3{
      margin:0;
      font-size: 18px;
      letter-spacing:-.2px;
    }
    .cardHeader .hint{
      font-size:12px;
      color: var(--muted);
      margin-top:4px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width:520px){
      .grid2{grid-template-columns: 1fr}
    }

    label{
      display:flex;
      flex-direction:column;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 700;
    }
    select, input{
      width:100%;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--text);
      padding: 12px 12px;
      font-size: 16px;
      outline:none;
      box-shadow: 0 10px 22px rgba(0,0,0,.06) inset;
    }
    select:focus, input:focus{
      box-shadow: 0 0 0 4px var(--focus);
      border-color: rgba(33,199,196,.55);
    }

    .modeRow{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      margin-top: 6px;
    }
    .pill{
      cursor:pointer;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--text);
      padding: 10px 12px;
      font-weight: 900;
      font-size: 14px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .08s ease, box-shadow .12s ease, background .12s ease;
    }
    .pill:active{transform: translateY(1px)}
    .pill.active{
      background: rgba(33,199,196,.12);
      border-color: rgba(33,199,196,.55);
      box-shadow: 0 10px 22px rgba(0,0,0,.08);
    }

    .saveRow{
      margin-top: 14px;
      display:flex;
      justify-content:flex-start;
    }
    .saveBtn{
      min-width: 190px;
    }

    /* Bottom navigation (only Home/Settings) */
    .bottomNav{
      position:fixed;
      left:50%;
      transform: translateX(-50%);
      bottom: calc(12px + var(--safeBottom));
      width: min(520px, calc(100% - 32px));
      background: #0c2a30;
      border-radius: 20px;
      padding: 10px;
      display:flex;
      gap: 10px;
      box-shadow: 0 18px 50px rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.08);
      z-index:50;
    }
    html[data-theme="dark"] .bottomNav, body[data-theme="dark"] .bottomNav{
      background: #081d22;
      border-color: rgba(255,255,255,.08);
    }
    .tab{
      flex:1;
      border:none;
      cursor:pointer;
      border-radius: 16px;
      padding: 12px 12px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
      font-weight: 900;
      font-size: 15px;
      background: transparent;
      color: rgba(234,247,247,.70);
      transition: background .12s ease, color .12s ease, transform .08s ease;
      -webkit-tap-highlight-color: transparent;
    }
    .tab:active{transform: translateY(1px)}
    .tab.active{
      background: rgba(255,255,255,.08);
      color: #eaf7f7;
      box-shadow: 0 12px 26px rgba(0,0,0,.20);
    }

    .hidden{display:none !important}

    /* GAME VIEW */
    .gameWrap{
      width:min(740px, 100%);
      display:flex;
      flex-direction:column;
      gap: 12px;
      align-items:center;
    }

    .gameTop{
      width:min(520px, 100%);
      border-radius: 22px;
      background: var(--card2);
      border: 1px solid var(--line);
      box-shadow: var(--shadowSoft);
      padding: 14px;
    }
    .gameTopHeader{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap: 10px;
    }
    .turnLine{
      font-weight: 900;
      font-size: 16px;
      margin:0;
      line-height:1.15;
    }
    .metaLine{
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 13px;
      font-weight: 800;
    }
    .exitBtn{
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--text);
      padding: 10px 12px;
      font-weight: 900;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .gameControls{
      margin-top: 12px;
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      align-items:center;
    }
    @media (max-width:520px){
      .gameControls{
        grid-template-columns: 1fr;
      }
    }

    .miniBtns{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
    }
    .miniBtn{
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--text);
      padding: 10px 12px;
      font-weight: 900;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .boardCard{
      width:min(520px, 100%);
      border-radius: 22px;
      background: var(--card2);
      border: 1px solid var(--line);
      box-shadow: var(--shadowSoft);
      padding: 14px;
    }

    /* Random "map-like" background behind the grid (CSS only) */
    .boardBg{
      border-radius: 20px;
      padding: 12px;
      background:
        radial-gradient(260px 200px at 18% 22%, rgba(33,199,196,.20), rgba(0,0,0,0) 60%),
        radial-gradient(300px 260px at 78% 40%, rgba(33,199,196,.16), rgba(0,0,0,0) 60%),
        radial-gradient(240px 240px at 46% 80%, rgba(0,0,0,.06), rgba(0,0,0,0) 62%),
        linear-gradient(180deg, rgba(255,255,255,.86), rgba(255,255,255,.74));
      border: 1px solid var(--line);
      position:relative;
      overflow:hidden;
    }
    html[data-theme="dark"] .boardBg, body[data-theme="dark"] .boardBg{
      background:
        radial-gradient(260px 200px at 18% 22%, rgba(33,199,196,.18), rgba(0,0,0,0) 60%),
        radial-gradient(300px 260px at 78% 40%, rgba(33,199,196,.12), rgba(0,0,0,0) 60%),
        radial-gradient(240px 240px at 46% 80%, rgba(0,0,0,.45), rgba(0,0,0,0) 62%),
        linear-gradient(180deg, rgba(10,33,38,.94), rgba(8,26,31,.94));
    }
    .boardBg::after{
      content:"";
      position:absolute;
      inset:-40px;
      opacity:.18;
      pointer-events:none;
      transform: rotate(-7deg);
      background:
        repeating-linear-gradient(0deg, rgba(255,255,255,.12) 0 1px, rgba(255,255,255,0) 1px 14px),
        repeating-linear-gradient(90deg, rgba(0,0,0,.10) 0 1px, rgba(0,0,0,0) 1px 18px);
      mix-blend-mode: overlay;
      filter: blur(.2px);
    }

    .grid{
      position:relative;
      display:grid;
      gap: var(--gridGap);
      justify-content:center;
      align-content:center;
      padding: 8px;
      z-index:1;
    }

    .cell{
      width: var(--cellSize);
      height: var(--cellSize);
      border-radius: var(--cellRadius);
      border: 1px solid var(--line);
      background: rgba(255,255,255,.80);
      display:grid;
      place-items:center;
      font-weight: 1000;
      font-size: 18px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 10px 22px rgba(0,0,0,.06);
      transition: transform .06s ease, background .12s ease;
    }
    html[data-theme="dark"] .cell, body[data-theme="dark"] .cell{
      background: rgba(255,255,255,.06);
      box-shadow: 0 10px 20px rgba(0,0,0,.22);
    }
    .cell:active{transform: translateY(1px)}
    .cell.disabled{cursor:default; opacity:.92}

    .markX{ color: #0f172a; }
    html[data-theme="dark"] .markX, body[data-theme="dark"] .markX{ color: #eaf7f7; }

    .markO{ color: #1aa8a4; }

    .markA{ color: #7c3aed; } /* player 3 */
    .markB{ color: #f59e0b; } /* player 4 */

    .toast{
      width:min(520px,100%);
      border-radius: 18px;
      padding: 12px 14px;
      background: var(--card2);
      border: 1px solid var(--line);
      box-shadow: var(--shadowSoft);
      color: var(--text);
      font-weight: 900;
      text-align:center;
    }

    /* Compact on small screens for bigger boards */
    @media (max-width:420px){
      :root{ --cellSize: 34px; --gridGap: 7px; --cellRadius: 13px; }
    }
    @media (max-width:360px){
      :root{ --cellSize: 30px; --gridGap: 6px; --cellRadius: 12px; }
    }
  </style>
</head>

<body>
  <div id="app" class="app" data-theme="light">
    <!-- Top chips -->
    <div class="topChips" id="topChips">
      <div class="chip">
        <div class="chipLogo">TT</div>
        <div class="chipText">
          <b id="appName">Tic-Tac-Toe+</b>
          <small id="appVer">v0</small>
        </div>
      </div>
      <!-- (no language/theme buttons here ‚Äî per your request) -->
      <div style="display:flex; gap:10px; align-items:center">
        <div class="chip" id="miniInfo" title="Version / build">
          <small id="miniBuild">build</small>
        </div>
      </div>
    </div>

    <!-- HOME PAGE (centered green block only) -->
    <div class="pageWrap" id="homePage">
      <div class="hero">
        <div class="heroInner">
          <div style="font-weight:900; font-size:13px; opacity:.92" id="homeLabel">–ì–ª–∞–≤–Ω–∞—è</div>
          <div class="heroTitle" id="homeTitle">Tic-Tac-Toe+</div>
          <div class="heroSub" id="homeSub"></div>

          <div class="heroBtns">
            <button class="btn btnPrimary" id="startBtn">
              ‚ñ∂ <span id="startBtnTxt">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</span>
            </button>
            <button class="btn btnGhost" id="continueBtn" disabled>
              ‚ñ∂ <span id="continueBtnTxt">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</span>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- SETTINGS PAGE (centered settings block only) -->
    <div class="pageWrap hidden" id="settingsPage">
      <div class="card">
        <div class="cardHeader">
          <div>
            <h3 id="settingsTitle">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
            <div class="hint" id="settingsHint">–°–æ—Ö—Ä–∞–Ω–∏ ‚Äî –∏ –Ω–∞–∂–º–∏ ‚Äú–ù–∞—á–∞—Ç—å –∏–≥—Ä—É‚Äù</div>
          </div>
          <div style="text-align:right">
            <div class="hint" id="settingsMeta">‚Äî</div>
          </div>
        </div>

        <div class="grid2">
          <label>
            <span id="lblLang">–Ø–∑—ã–∫</span>
            <select id="selLang">
              <option value="ru">–†—É—Å—Å–∫–∏–π</option>
              <option value="en">English</option>
              <option value="uz">O‚Äòzbek (lotin)</option>
            </select>
          </label>

          <label>
            <span id="lblTheme">–¢–µ–º–∞</span>
            <select id="selTheme">
              <option value="light">Light</option>
              <option value="dark">Dark</option>
            </select>
          </label>
        </div>

        <div style="margin-top:14px;">
          <div style="font-size:12px; color:var(--muted); font-weight:800" id="lblMode">–†–µ–∂–∏–º</div>
          <div class="modeRow" id="modeRow"></div>
        </div>

        <div class="grid2" style="margin-top:14px;">
          <label>
            <span id="lblSize">–†–∞–∑–º–µ—Ä –ø–æ–ª—è</span>
            <select id="selSize"></select>
          </label>
          <label>
            <span id="lblGoal">–¶–µ–ª—å (–≤ —Ä—è–¥)</span>
            <select id="selGoal"></select>
          </label>
        </div>

        <div class="grid2" style="margin-top:14px;">
          <label id="aiDiffWrap">
            <span id="lblAi">–°–ª–æ–∂–Ω–æ—Å—Ç—å –ò–ò</span>
            <select id="selAi">
              <option value="easy">–õ—ë–≥–∫–∞—è</option>
              <option value="medium">–°—Ä–µ–¥–Ω—è—è</option>
              <option value="hard">–°–ª–æ–∂–Ω–∞—è</option>
              <option value="expert">–≠–∫—Å–ø–µ—Ä—Ç</option>
            </select>
          </label>
          <label>
            <span id="lblTexture">–¢–µ–∫—Å—Ç—É—Ä–∞</span>
            <select id="selTexture">
              <option value="grid">Grid</option>
              <option value="paper">Paper</option>
              <option value="noise">Noise</option>
            </select>
          </label>
        </div>

        <div class="grid2" style="margin-top:14px;">
          <label>
            <span id="lblP1">–ò–≥—Ä–æ–∫ 1 (X)</span>
            <input id="inP1" placeholder="Alex" />
          </label>
          <label id="p2Wrap">
            <span id="lblP2">–ò–≥—Ä–æ–∫ 2 (O)</span>
            <input id="inP2" placeholder="Player 2" />
          </label>
        </div>

        <div class="grid2" style="margin-top:12px;">
          <label class="hidden" id="p3Wrap">
            <span id="lblP3">–ò–≥—Ä–æ–∫ 3 (‚ñ≤)</span>
            <input id="inP3" placeholder="Player 3" />
          </label>
          <label class="hidden" id="p4Wrap">
            <span id="lblP4">–ò–≥—Ä–æ–∫ 4 (‚ñ†)</span>
            <input id="inP4" placeholder="Player 4" />
          </label>
        </div>

        <!-- Rules moved here (per your request) -->
        <div style="margin-top:14px; border-top:1px solid var(--line); padding-top:12px;">
          <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
            <div style="font-weight:1000" id="rulesTitle">–ü—Ä–∞–≤–∏–ª–∞</div>
            <button class="miniBtn" id="toggleRules">‚ñº</button>
          </div>
          <div id="rulesBox" class="hidden" style="margin-top:10px; color:var(--muted); font-weight:800; font-size:13px; line-height:1.35;">
            <div id="rulesText"></div>
          </div>
        </div>

        <div class="saveRow">
          <button class="btn btnSolid saveBtn" id="saveBtn">
            <span id="saveBtnTxt">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</span>
          </button>
        </div>
      </div>
    </div>

    <!-- GAME VIEW (no green block, no bottom tabs, no rules button) -->
    <div class="gameWrap hidden" id="gamePage">
      <div class="gameTop">
        <div class="gameTopHeader">
          <div>
            <p class="turnLine" id="turnLine">–•–æ–¥–∏—Ç: ‚Äî</p>
            <p class="metaLine" id="metaLine">‚Äî</p>
          </div>
          <button class="exitBtn" id="exitBtn">‚úï <span id="exitTxt">–í—ã–π—Ç–∏</span></button>
        </div>

        <div class="gameControls">
          <label>
            <span id="lblGoalInGame">–¶–µ–ª—å (–≤ —Ä—è–¥)</span>
            <select id="selGoalInGame"></select>
          </label>

          <div class="miniBtns">
            <button class="miniBtn" id="undoBtn">‚Ü© <span id="undoTxt">–û—Ç–º–µ–Ω–∏—Ç—å</span></button>
            <button class="miniBtn" id="restartBtn">‚ü≤ <span id="restartTxt">–†–µ—Å—Ç–∞—Ä—Ç</span></button>
            <button class="miniBtn" id="menuBtn">‚ò∞ <span id="menuTxt">–ú–µ–Ω—é</span></button>
          </div>

          <button class="miniBtn" id="randomMapBtn">üó∫ <span id="mapTxt">–°–ª—É—á. –∫–∞—Ä—Ç–∞</span></button>
        </div>
      </div>

      <div class="boardCard">
        <div class="boardBg" id="boardBg">
          <div class="grid" id="grid"></div>
        </div>
      </div>

      <div class="toast hidden" id="toast"></div>
    </div>

    <!-- Bottom nav (only Home / Settings, hidden in Game) -->
    <div class="bottomNav" id="bottomNav">
      <button class="tab active" id="tabHome">‚åÇ <span id="tabHomeTxt">–ì–ª–∞–≤–Ω–∞—è</span></button>
      <button class="tab" id="tabSettings">‚öô <span id="tabSettingsTxt">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</span></button>
    </div>
  </div>

<script>
(() => {
  /* =======================
     VERSION (cache-bust)
  ======================== */
  const APP_VERSION = "2025.12.22.2"; // <-- when you update code, bump this
  const BUILD_STAMP = new Date().toISOString().slice(0,19).replace("T"," ");
  document.getElementById("appVer").textContent = "v" + APP_VERSION;
  document.getElementById("miniBuild").textContent = "build " + APP_VERSION;

  // Telegram WebView cache-bust trick:
  // If URL doesn't have ?v=APP_VERSION, auto-add it and reload once.
  try{
    const url = new URL(location.href);
    if (url.searchParams.get("v") !== APP_VERSION){
      url.searchParams.set("v", APP_VERSION);
      history.replaceState(null, "", url.toString());
      // Force reload only once per version
      const k = "tt_force_reload_" + APP_VERSION;
      if (!localStorage.getItem(k)){
        localStorage.setItem(k, "1");
        location.reload();
      }
    }
  }catch(e){}

  /* =======================
     Helpers / state
  ======================== */
  const $ = (id) => document.getElementById(id);

  const DEFAULT = {
    lang: "ru",
    theme: "light",
    texture: "grid",
    mode: "pvp", // pvp | ai | p3 | p4
    size: 8,
    goal: 5,
    ai: "expert",
    names: ["Alex", "Player 2", "Player 3", "Player 4"],
    inGame: false,
    board: [],
    turn: 0, // index of current player
    history: [],
    savedAt: null,
    mapSeed: 1
  };

  let S = loadState();

  function loadState(){
    try{
      const raw = localStorage.getItem("ttplus_state_v2");
      if (!raw) return structuredClone(DEFAULT);
      const o = JSON.parse(raw);
      // merge defaults
      const s = structuredClone(DEFAULT);
      Object.assign(s, o);
      // safety clamps
      s.size = clampInt(s.size, 3, 10);
      s.goal = clampInt(s.goal, 3, s.size);
      s.mapSeed = clampInt(s.mapSeed || 1, 1, 999999);
      if (!Array.isArray(s.names)) s.names = structuredClone(DEFAULT.names);
      return s;
    }catch(e){
      return structuredClone(DEFAULT);
    }
  }

  function saveState(){
    try{
      localStorage.setItem("ttplus_state_v2", JSON.stringify(S));
    }catch(e){}
    updateContinue();
  }

  function clampInt(n, a, b){
    n = parseInt(n,10);
    if (Number.isNaN(n)) n = a;
    return Math.max(a, Math.min(b, n));
  }

  /* =======================
     I18N
  ======================== */
  const I18N = {
    ru:{
      home:"–ì–ª–∞–≤–Ω–∞—è",
      settings:"–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
      start:"–ù–∞—á–∞—Ç—å –∏–≥—Ä—É",
      continue:"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å",
      noSaved:"–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è",
      save:"–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
      lang:"–Ø–∑—ã–∫",
      theme:"–¢–µ–º–∞",
      mode:"–†–µ–∂–∏–º",
      size:"–†–∞–∑–º–µ—Ä –ø–æ–ª—è",
      goal:"–¶–µ–ª—å (–≤ —Ä—è–¥)",
      ai:"–°–ª–æ–∂–Ω–æ—Å—Ç—å –ò–ò",
      texture:"–¢–µ–∫—Å—Ç—É—Ä–∞",
      p1:"–ò–≥—Ä–æ–∫ 1 (X)",
      p2:"–ò–≥—Ä–æ–∫ 2 (O)",
      p3:"–ò–≥—Ä–æ–∫ 3 (‚ñ≤)",
      p4:"–ò–≥—Ä–æ–∫ 4 (‚ñ†)",
      exit:"–í—ã–π—Ç–∏",
      turn:"–•–æ–¥–∏—Ç",
      undo:"–û—Ç–º–µ–Ω–∏—Ç—å",
      restart:"–†–µ—Å—Ç–∞—Ä—Ç",
      menu:"–ú–µ–Ω—é",
      map:"–°–ª—É—á. –∫–∞—Ä—Ç–∞",
      rules:"–ü—Ä–∞–≤–∏–ª–∞",
      rulesTxt:
        "–í—ã–±–∏—Ä–∞–π —Ä–µ–∂–∏–º, —Ä–∞–∑–º–µ—Ä –ø–æ–ª—è –∏ —Ü–µ–ª—å (—Å–∫–æ–ª—å–∫–æ —Å–∏–º–≤–æ–ª–æ–≤ –ø–æ–¥—Ä—è–¥ –Ω—É–∂–Ω–æ —Å–æ–±—Ä–∞—Ç—å). " +
        "–í –∏–≥—Ä–µ –º–æ–∂–Ω–æ –º–µ–Ω—è—Ç—å —Ü–µ–ª—å (–≤ —Ä—è–¥) –ø—Ä—è–º–æ –≤–æ –≤—Ä–µ–º—è –º–∞—Ç—á–∞. " +
        "–ü–æ–±–µ–¥–∞: —Å–æ–±–µ—Ä–∏ —Å–≤–æ—é —Ü–µ–ª—å –ø–æ–¥—Ä—è–¥ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏, –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ –∏–ª–∏ –¥–∏–∞–≥–æ–Ω–∞–ª–∏. " +
        "–ù–∏—á—å—è: –µ—Å–ª–∏ —Ö–æ–¥–æ–≤ –Ω–µ—Ç –∏ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è –Ω–µ—Ç.",
      mode_pvp:"–ò–≥—Ä–æ–∫ vs –ò–≥—Ä–æ–∫",
      mode_ai:"–ò–≥—Ä–æ–∫ vs –ò–ò",
      mode_p3:"3 –∏–≥—Ä–æ–∫–∞",
      mode_p4:"4 –∏–≥—Ä–æ–∫–∞",
      ai_easy:"–õ—ë–≥–∫–∞—è",
      ai_medium:"–°—Ä–µ–¥–Ω—è—è",
      ai_hard:"–°–ª–æ–∂–Ω–∞—è",
      ai_expert:"–≠–∫—Å–ø–µ—Ä—Ç",
      light:"Light",
      dark:"Dark",
      tex_grid:"Grid",
      tex_paper:"Paper",
      tex_noise:"Noise",
      winner:"–ü–æ–±–µ–¥–∏—Ç–µ–ª—å",
      draw:"–ù–∏—á—å—è",
      saved:"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ",
      notSaved:"–°–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –∏–≥—Ä—ã –Ω–µ—Ç",
      started:"–ò–≥—Ä–∞ –Ω–∞—á–∞—Ç–∞",
      resumed:"–ò–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∞",
      finished:"–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞",
      closeRules:"–°–∫—Ä—ã—Ç—å",
      openRules:"–ü–æ–∫–∞–∑–∞—Ç—å",
      settingsHint:"–°–æ—Ö—Ä–∞–Ω–∏ ‚Äî –∏ –Ω–∞–∂–º–∏ ‚Äú–ù–∞—á–∞—Ç—å –∏–≥—Ä—É‚Äù"
    },
    en:{
      home:"Home",
      settings:"Settings",
      start:"Start game",
      continue:"Continue",
      noSaved:"No saved game",
      save:"Save",
      lang:"Language",
      theme:"Theme",
      mode:"Mode",
      size:"Board size",
      goal:"Goal (in a row)",
      ai:"AI difficulty",
      texture:"Texture",
      p1:"Player 1 (X)",
      p2:"Player 2 (O)",
      p3:"Player 3 (‚ñ≤)",
      p4:"Player 4 (‚ñ†)",
      exit:"Exit",
      turn:"Turn",
      undo:"Undo",
      restart:"Restart",
      menu:"Menu",
      map:"Random map",
      rules:"Rules",
      rulesTxt:
        "Choose mode, board size and goal (how many in a row). " +
        "You can change the goal during the game. " +
        "Win: reach your goal in a row horizontally, vertically or diagonally. " +
        "Draw: no moves left and no winner.",
      mode_pvp:"Player vs Player",
      mode_ai:"Player vs AI",
      mode_p3:"3 players",
      mode_p4:"4 players",
      ai_easy:"Easy",
      ai_medium:"Medium",
      ai_hard:"Hard",
      ai_expert:"Expert",
      light:"Light",
      dark:"Dark",
      tex_grid:"Grid",
      tex_paper:"Paper",
      tex_noise:"Noise",
      winner:"Winner",
      draw:"Draw",
      saved:"Saved",
      notSaved:"No saved game",
      started:"Game started",
      resumed:"Game resumed",
      finished:"Game finished",
      closeRules:"Hide",
      openRules:"Show",
      settingsHint:"Save ‚Äî then tap ‚ÄúStart game‚Äù"
    },
    uz:{
      home:"Bosh sahifa",
      settings:"Sozlamalar",
      start:"O‚Äòyinni boshlash",
      continue:"Davom ettirish",
      noSaved:"Saqlangan o‚Äòyin yo‚Äòq",
      save:"Saqlash",
      lang:"Til",
      theme:"Mavzu",
      mode:"Rejim",
      size:"Maydon o‚Äòlchami",
      goal:"Maqsad (qator)",
      ai:"AI qiyinligi",
      texture:"Tekstura",
      p1:"1-o‚Äòyinchi (X)",
      p2:"2-o‚Äòyinchi (O)",
      p3:"3-o‚Äòyinchi (‚ñ≤)",
      p4:"4-o‚Äòyinchi (‚ñ†)",
      exit:"Chiqish",
      turn:"Navbat",
      undo:"Bekor qilish",
      restart:"Qayta boshlash",
      menu:"Menyu",
      map:"Tasodifiy xarita",
      rules:"Qoidalar",
      rulesTxt:
        "Rejim, maydon va maqsadni tanlang (qator bo‚Äòylab nechta). " +
        "O‚Äòyin davomida maqsadni o‚Äòzgartirish mumkin. " +
        "G‚Äòalaba: gorizontal/vertikal/diagonal bo‚Äòyicha maqsadga yeting. " +
        "Durang: yurish qolmasa va g‚Äòolib bo‚Äòlmasa.",
      mode_pvp:"O‚Äòyinchi vs O‚Äòyinchi",
      mode_ai:"O‚Äòyinchi vs AI",
      mode_p3:"3 o‚Äòyinchi",
      mode_p4:"4 o‚Äòyinchi",
      ai_easy:"Oson",
      ai_medium:"O‚Äòrtacha",
      ai_hard:"Qiyin",
      ai_expert:"Ekspert",
      light:"Light",
      dark:"Dark",
      tex_grid:"Grid",
      tex_paper:"Paper",
      tex_noise:"Noise",
      winner:"G‚Äòolib",
      draw:"Durang",
      saved:"Saqlangan",
      notSaved:"Saqlangan o‚Äòyin yo‚Äòq",
      started:"O‚Äòyin boshlandi",
      resumed:"O‚Äòyin davom etdi",
      finished:"O‚Äòyin tugadi",
      closeRules:"Yopish",
      openRules:"Ko‚Äòrsatish",
      settingsHint:"Saqlang ‚Äî so‚Äòng ‚ÄúO‚Äòyinni boshlash‚Äùni bosing"
    }
  };

  function t(key){
    return (I18N[S.lang] && I18N[S.lang][key]) || I18N.ru[key] || key;
  }

  /* =======================
     Theme + texture
  ======================== */
  const app = $("app");
  function applyTheme(){
    app.setAttribute("data-theme", S.theme);
    document.body.setAttribute("data-theme", S.theme);
    document.documentElement.setAttribute("data-theme", S.theme);
    $("selTheme").value = S.theme;
  }

  function applyTexture(){
    // we change body::after effect via CSS variables
    if (S.texture === "grid"){
      document.documentElement.style.setProperty("--textureOpacity", (S.theme==="dark") ? ".10" : ".08");
      document.body.style.filter = "";
    }else if (S.texture === "paper"){
      document.documentElement.style.setProperty("--textureOpacity", (S.theme==="dark") ? ".12" : ".10");
      document.body.style.filter = "saturate(.98)";
    }else{ // noise
      document.documentElement.style.setProperty("--textureOpacity", (S.theme==="dark") ? ".16" : ".14");
      document.body.style.filter = "contrast(1.02)";
    }
    $("selTexture").value = S.texture;

    // tweak body::after by toggling classes? keep simple: we vary blend mode via inline style
    // (not necessary‚Äîopacity already changes)
  }

  /* =======================
     Pages
  ======================== */
  const homePage = $("homePage");
  const settingsPage = $("settingsPage");
  const gamePage = $("gamePage");
  const bottomNav = $("bottomNav");
  const tabHome = $("tabHome");
  const tabSettings = $("tabSettings");

  function showPage(page){
    homePage.classList.toggle("hidden", page!=="home");
    settingsPage.classList.toggle("hidden", page!=="settings");
    gamePage.classList.toggle("hidden", page!=="game");

    bottomNav.classList.toggle("hidden", page==="game");

    tabHome.classList.toggle("active", page==="home");
    tabSettings.classList.toggle("active", page==="settings");
  }

  tabHome.onclick = () => showPage("home");
  tabSettings.onclick = () => showPage("settings");

  /* =======================
     Settings UI build
  ======================== */
  const modeRow = $("modeRow");

  function buildModes(){
    modeRow.innerHTML = "";
    const modes = [
      ["pvp","mode_pvp"],
      ["ai","mode_ai"],
      ["p3","mode_p3"],
      ["p4","mode_p4"]
    ];
    for (const [val,key] of modes){
      const b = document.createElement("button");
      b.className = "pill" + (S.mode===val ? " active" : "");
      b.type = "button";
      b.textContent = t(key);
      b.onclick = () => {
        S.mode = val;
        if (S.mode === "ai") S.names[1] = botName();
        syncPlayerInputs();
        buildModes();
        refreshSettingsMeta();
        saveState();
      };
      modeRow.appendChild(b);
    }
  }

  function buildSizes(){
    const sel = $("selSize");
    sel.innerHTML = "";
    for (let n=3;n<=10;n++){
      const opt = document.createElement("option");
      opt.value = String(n);
      opt.textContent = `${n}√ó${n}`;
      sel.appendChild(opt);
    }
    sel.value = String(S.size);
    sel.onchange = () => {
      S.size = clampInt(sel.value, 3, 10);
      // adjust goal range
      S.goal = clampInt(S.goal, 3, S.size);
      buildGoals();
      refreshSettingsMeta();
      saveState();
    };
  }

  function buildGoals(){
    const sel = $("selGoal");
    sel.innerHTML = "";
    for (let g=3; g<=S.size; g++){
      const opt = document.createElement("option");
      opt.value = String(g);
      opt.textContent = String(g);
      sel.appendChild(opt);
    }
    sel.value = String(S.goal);
    sel.onchange = () => {
      S.goal = clampInt(sel.value, 3, S.size);
      refreshSettingsMeta();
      saveState();
    };

    // also game dropdown (if already exists)
    buildGoalsInGame();
  }

  function buildGoalsInGame(){
    const sel = $("selGoalInGame");
    sel.innerHTML = "";
    for (let g=3; g<=S.size; g++){
      const opt = document.createElement("option");
      opt.value = String(g);
      opt.textContent = `${t("goal")}: ${g}`;
      sel.appendChild(opt);
    }
    sel.value = String(S.goal);
    sel.onchange = () => {
      S.goal = clampInt(sel.value, 3, S.size);
      // check if someone already won with new goal (optional) -> we'll just continue safely
      renderGameTop();
      saveState();
    };
  }

  function syncPlayerInputs(){
    $("inP1").value = S.names[0] || "Alex";
    $("inP2").value = S.names[1] || "Player 2";
    $("inP3").value = S.names[2] || "Player 3";
    $("inP4").value = S.names[3] || "Player 4";

    // show/hide inputs based on mode
    const p2Wrap = $("p2Wrap");
    const p3Wrap = $("p3Wrap");
    const p4Wrap = $("p4Wrap");
    const aiDiffWrap = $("aiDiffWrap");

    p2Wrap.classList.toggle("hidden", false);
    p3Wrap.classList.toggle("hidden", !(S.mode==="p3" || S.mode==="p4"));
    p4Wrap.classList.toggle("hidden", !(S.mode==="p4"));
    aiDiffWrap.classList.toggle("hidden", S.mode!=="ai");

    // if ai mode, lock p2 name to bot
    if (S.mode === "ai"){
      $("inP2").value = botName();
      $("inP2").setAttribute("disabled","disabled");
    }else{
      $("inP2").removeAttribute("disabled");
    }
  }

  function botName(){
    if (S.lang==="ru") return "–ë–æ—Ç";
    if (S.lang==="uz") return "Bot";
    return "Bot";
  }

  $("selLang").onchange = () => {
    S.lang = $("selLang").value;
    if (S.mode === "ai") S.names[1] = botName();
    applyI18n();
    buildModes();
    syncPlayerInputs();
    refreshSettingsMeta();
    renderHomeSummary();
    renderGameTop();
    saveState();
  };

  $("selTheme").onchange = () => {
    S.theme = $("selTheme").value;
    applyTheme();
    applyTexture();
    saveState();
  };

  $("selAi").onchange = () => { S.ai = $("selAi").value; refreshSettingsMeta(); saveState(); };
  $("selTexture").onchange = () => { S.texture = $("selTexture").value; applyTexture(); saveState(); };

  $("inP1").oninput = () => { S.names[0] = $("inP1").value.trim() || "Alex"; renderHomeSummary(); saveState(); };
  $("inP2").oninput = () => { if (S.mode!=="ai") { S.names[1] = $("inP2").value.trim() || "Player 2"; renderHomeSummary(); saveState(); } };
  $("inP3").oninput = () => { S.names[2] = $("inP3").value.trim() || "Player 3"; renderHomeSummary(); saveState(); };
  $("inP4").oninput = () => { S.names[3] = $("inP4").value.trim() || "Player 4"; renderHomeSummary(); saveState(); };

  function refreshSettingsMeta(){
    $("settingsMeta").textContent = `${S.size}√ó${S.size} ¬∑ ${t("goal")}: ${S.goal}`;
  }

  /* =======================
     Rules toggle
  ======================== */
  $("toggleRules").onclick = () => {
    const box = $("rulesBox");
    const open = box.classList.toggle("hidden");
    // open==true means hidden; so reversed
    $("toggleRules").textContent = box.classList.contains("hidden") ? "‚ñº" : "‚ñ≤";
  };

  /* =======================
     Home summary
  ======================== */
  function modeLabel(){
    if (S.mode==="pvp") return t("mode_pvp");
    if (S.mode==="ai") return t("mode_ai");
    if (S.mode==="p3") return t("mode_p3");
    return t("mode_p4");
  }

  function playersLine(){
    const marks = ["X","O","‚ñ≤","‚ñ†"];
    const pCount = (S.mode==="p3") ? 3 : (S.mode==="p4") ? 4 : 2;
    const names = S.names.slice(0,pCount).map((n,i)=>`${n || ("P"+(i+1))} (${marks[i]})`);
    return names.join(", ");
  }

  function renderHomeSummary(){
    // keep minimal text (you asked less info per block)
    $("homeLabel").textContent = t("home");
    $("homeTitle").textContent = "Tic-Tac-Toe+";
    $("homeSub").textContent =
      `${modeLabel()} ¬∑ ${S.size}√ó${S.size} ¬∑ ${t("goal")}: ${S.goal}\n` +
      `${playersLine()}`;
    $("startBtnTxt").textContent = t("start");
    $("continueBtnTxt").textContent = t("continue");
  }

  function applyI18n(){
    $("tabHomeTxt").textContent = t("home");
    $("tabSettingsTxt").textContent = t("settings");

    $("settingsTitle").textContent = t("settings");
    $("settingsHint").textContent = t("settingsHint");

    $("lblLang").textContent = t("lang");
    $("lblTheme").textContent = t("theme");
    $("lblMode").textContent = t("mode");
    $("lblSize").textContent = t("size");
    $("lblGoal").textContent = t("goal");
    $("lblAi").textContent = t("ai");
    $("lblTexture").textContent = t("texture");
    $("lblP1").textContent = t("p1");
    $("lblP2").textContent = t("p2");
    $("lblP3").textContent = t("p3");
    $("lblP4").textContent = t("p4");
    $("saveBtnTxt").textContent = t("save");

    $("rulesTitle").textContent = t("rules");
    $("rulesText").textContent = t("rulesTxt");

    $("exitTxt").textContent = t("exit");
    $("undoTxt").textContent = t("undo");
    $("restartTxt").textContent = t("restart");
    $("menuTxt").textContent = t("menu");
    $("mapTxt").textContent = t("map");
    $("lblGoalInGame").textContent = t("goal");

    // select labels (theme/texture show as-is)
    const selTheme = $("selTheme");
    selTheme.options[0].textContent = t("light");
    selTheme.options[1].textContent = t("dark");

    const selTex = $("selTexture");
    selTex.options[0].textContent = t("tex_grid");
    selTex.options[1].textContent = t("tex_paper");
    selTex.options[2].textContent = t("tex_noise");

    const selAi = $("selAi");
    selAi.options[0].textContent = t("ai_easy");
    selAi.options[1].textContent = t("ai_medium");
    selAi.options[2].textContent = t("ai_hard");
    selAi.options[3].textContent = t("ai_expert");

    $("selLang").value = S.lang;
  }

  /* =======================
     Start / continue / save
  ======================== */
  function updateContinue(){
    const hasSaved = !!(S.inGame && S.board && S.board.length);
    $("continueBtn").disabled = !hasSaved;
    $("continueBtnTxt").textContent = hasSaved ? t("continue") : t("noSaved");
  }

  $("saveBtn").onclick = () => {
    // Also normalize goal options
    S.size = clampInt($("selSize").value, 3, 10);
    S.goal = clampInt($("selGoal").value, 3, S.size);
    S.lang = $("selLang").value;
    S.theme = $("selTheme").value;
    S.ai = $("selAi").value;
    S.texture = $("selTexture").value;

    S.names[0] = $("inP1").value.trim() || "Alex";
    if (S.mode !== "ai") S.names[1] = $("inP2").value.trim() || "Player 2";
    else S.names[1] = botName();
    S.names[2] = $("inP3").value.trim() || "Player 3";
    S.names[3] = $("inP4").value.trim() || "Player 4";

    S.savedAt = Date.now();

    applyTheme();
    applyTexture();
    applyI18n();
    buildModes();
    syncPlayerInputs();
    buildGoals();
    refreshSettingsMeta();
    renderHomeSummary();

    toast(t("saved"));
    saveState();
  };

  $("startBtn").onclick = () => {
    startNewGame();
  };

  $("continueBtn").onclick = () => {
    if (S.inGame && S.board && S.board.length){
      showGame();
      toast(t("resumed"));
      maybeAIMove();
    }else{
      toast(t("notSaved"));
    }
  };

  /* =======================
     Game logic
  ======================== */
  const grid = $("grid");
  const toastEl = $("toast");

  const MARKS = ["X","O","‚ñ≤","‚ñ†"];
  const CLASSES = ["markX","markO","markA","markB"];

  function startNewGame(){
    S.size = clampInt(S.size, 3, 10);
    S.goal = clampInt(S.goal, 3, S.size);

    const cells = S.size * S.size;
    S.board = new Array(cells).fill(-1);
    S.turn = 0;
    S.history = [];
    S.inGame = true;
    S.mapSeed = (S.mapSeed || 1) + 1;

    // If AI mode, ensure bot name
    if (S.mode === "ai") S.names[1] = botName();

    saveState();
    showGame();
    toast(t("started"));
    maybeAIMove();
  }

  function showGame(){
    showPage("game");
    renderGameTop();
    renderGrid();
    applyMapSeed();
  }

  function backToMenu(){
    // keep inGame state as "saved" so continue works
    showPage("home");
    renderHomeSummary();
    updateContinue();
  }

  $("menuBtn").onclick = backToMenu;
  $("exitBtn").onclick = () => {
    // exit ends the game (no need to keep green block etc)
    S.inGame = false;
    S.board = [];
    S.history = [];
    saveState();
    showPage("home");
    renderHomeSummary();
    updateContinue();
    toast(t("finished"));
  };

  $("restartBtn").onclick = () => startNewGame();

  $("undoBtn").onclick = () => {
    undoMove();
  };

  $("randomMapBtn").onclick = () => {
    S.mapSeed = (S.mapSeed || 1) + 1;
    applyMapSeed();
    saveState();
  };

  function renderGameTop(){
    if (!S.inGame) return;
    const pCount = (S.mode==="p3") ? 3 : (S.mode==="p4") ? 4 : 2;
    const who = currentPlayerName();
    $("turnLine").textContent = `${t("turn")}: ${who} (${MARKS[S.turn]})`;

    $("metaLine").textContent = `${S.size}√ó${S.size} ¬∑ ${t("goal")}: ${S.goal}`;

    buildGoalsInGame();

    // Undo only if history exists
    $("undoBtn").disabled = !S.history.length;
  }

  function currentPlayerName(){
    return (S.names[S.turn] || ("P"+(S.turn+1)));
  }

  function renderGrid(){
    grid.innerHTML = "";
    grid.style.gridTemplateColumns = `repeat(${S.size}, var(--cellSize))`;
    const total = S.size * S.size;

    for (let i=0;i<total;i++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.i = String(i);

      const v = S.board[i];
      if (v >= 0){
        cell.textContent = MARKS[v];
        cell.classList.add(CLASSES[v]);
        cell.classList.add("disabled");
      }else{
        cell.textContent = "";
      }

      cell.onclick = () => {
        if (!S.inGame) return;
        if (S.board[i] !== -1) return;
        if (isAITurn()) return; // block clicking while AI should move
        doMove(i, S.turn);
      };

      grid.appendChild(cell);
    }
  }

  function isAITurn(){
    return S.mode==="ai" && S.turn===1;
  }

  function doMove(index, player){
    if (S.board[index] !== -1) return;

    // push snapshot for undo
    S.history.push({
      index,
      prev: -1,
      turnBefore: player,
      goalBefore: S.goal
    });

    S.board[index] = player;

    // render only that cell
    const cell = grid.querySelector(`.cell[data-i="${index}"]`);
    if (cell){
      cell.textContent = MARKS[player];
      cell.classList.add(CLASSES[player], "disabled");
    }

    // check win/draw
    const win = checkWinner(player);
    if (win){
      toast(`${t("winner")}: ${S.names[player] || ("P"+(player+1))} (${MARKS[player]})`);
      // keep game but stop moves
      S.inGame = false;
      saveState();
      // hide bottom nav already hidden; allow exit/menu
      renderGameTop();
      return;
    }
    if (isDraw()){
      toast(t("draw"));
      S.inGame = false;
      saveState();
      renderGameTop();
      return;
    }

    // next turn
    const pCount = (S.mode==="p3") ? 3 : (S.mode==="p4") ? 4 : 2;
    S.turn = (S.turn + 1) % pCount;

    renderGameTop();
    saveState();

    maybeAIMove();
  }

  function undoMove(){
    if (!S.history.length) return;
    // In AI mode we often want undo 2 moves (player + bot) for convenience.
    if (S.mode==="ai"){
      // undo last move
      popUndoOnce();
      // if still last move belongs to AI, undo again
      if (S.history.length && S.turn===1){
        popUndoOnce();
      }
    }else{
      popUndoOnce();
    }

    renderGrid();
    renderGameTop();
    saveState();
  }

  function popUndoOnce(){
    const last = S.history.pop();
    if (!last) return;
    S.board[last.index] = -1;
    S.turn = last.turnBefore; // restore turn
    // we keep goal as current (goal can be changed mid-game); no revert needed
  }

  function isDraw(){
    return S.board.every(v => v !== -1);
  }

  function checkWinner(player){
    const n = S.size;
    const need = S.goal;
    const b = S.board;

    // scan all cells as start points, check 4 directions
    const dirs = [
      [1,0],  // down
      [0,1],  // right
      [1,1],  // diag down-right
      [1,-1]  // diag down-left
    ];

    for (let r=0;r<n;r++){
      for (let c=0;c<n;c++){
        if (b[r*n+c] !== player) continue;
        for (const [dr,dc] of dirs){
          let ok = true;
          for (let k=1;k<need;k++){
            const rr = r + dr*k;
            const cc = c + dc*k;
            if (rr<0 || rr>=n || cc<0 || cc>=n){ ok=false; break; }
            if (b[rr*n+cc] !== player){ ok=false; break; }
          }
          if (ok) return true;
        }
      }
    }
    return false;
  }

  /* =======================
     AI (heuristic + limited search)
  ======================== */
  function maybeAIMove(){
    if (!S.inGame) return;
    if (!isAITurn()) return;

    // give UI a tick
    setTimeout(() => {
      const move = aiChooseMove();
      if (move !== null && S.inGame){
        doMove(move, 1);
      }
    }, 120);
  }

  function aiChooseMove(){
    const empties = [];
    for (let i=0;i<S.board.length;i++){
      if (S.board[i] === -1) empties.push(i);
    }
    if (!empties.length) return null;

    // 1) win if possible
    for (const idx of empties){
      S.board[idx] = 1;
      const w = checkWinner(1);
      S.board[idx] = -1;
      if (w) return idx;
    }
    // 2) block opponent win
    for (const idx of empties){
      S.board[idx] = 0;
      const w = checkWinner(0);
      S.board[idx] = -1;
      if (w) return idx;
    }

    // Difficulty affects "scoring" and randomness
    const level = S.ai || "expert";
    let randomness = 0.35;
    let look = 1; // heuristic depth
    if (level==="easy"){ randomness = 0.65; look = 1; }
    if (level==="medium"){ randomness = 0.45; look = 1; }
    if (level==="hard"){ randomness = 0.20; look = 2; }
    if (level==="expert"){ randomness = 0.08; look = 2; }

    // On big boards, keep it light
    if (S.size >= 7) look = 1;

    // Score moves
    let best = [];
    let bestScore = -Infinity;
    for (const idx of empties){
      const score = scoreMove(idx, 1) - scoreMove(idx, 0)*0.92;
      if (score > bestScore){
        bestScore = score;
        best = [idx];
      }else if (Math.abs(score - bestScore) < 1e-6){
        best.push(idx);
      }
    }

    // randomness
    if (Math.random() < randomness){
      return empties[Math.floor(Math.random()*empties.length)];
    }

    // choose among best
    return best[Math.floor(Math.random()*best.length)];
  }

  function scoreMove(idx, player){
    // heuristic: count potentials in lines through idx
    const n = S.size;
    const need = S.goal;
    const b = S.board;

    // temporarily place
    b[idx] = player;
    const r0 = Math.floor(idx / n);
    const c0 = idx % n;

    const dirs = [
      [1,0],
      [0,1],
      [1,1],
      [1,-1]
    ];

    let score = 0;

    for (const [dr,dc] of dirs){
      // we look in a window around idx
      let line = [];
      for (let t=- (need-1); t<= (need-1); t++){
        const rr = r0 + dr*t;
        const cc = c0 + dc*t;
        if (rr<0||rr>=n||cc<0||cc>=n) line.push(null);
        else line.push(b[rr*n+cc]);
      }

      // evaluate all segments of length need
      for (let s=0; s+need<=line.length; s++){
        const seg = line.slice(s, s+need);
        if (seg.includes(null)) continue;
        // block if enemy present
        const enemy = seg.some(v => v !== -1 && v !== player);
        if (enemy) continue;
        const mine = seg.filter(v => v === player).length;
        const empty = seg.filter(v => v === -1).length;
        if (mine === need) score += 100000;
        else if (mine === need-1 && empty === 1) score += 2200;
        else if (mine === need-2 && empty === 2) score += 520;
        else if (mine >= 1) score += 40 * mine;
        else score += 6; // pure empty segment still matters a bit
      }
    }

    // center preference
    const cr = (n-1)/2, cc = (n-1)/2;
    const dist = Math.abs(r0 - cr) + Math.abs(c0 - cc);
    score += Math.max(0, 25 - dist*4);

    b[idx] = -1;
    return score;
  }

  /* =======================
     "Map" background generator (CSS-only)
  ======================== */
  function applyMapSeed(){
    // use seed to change gradients slightly
    const seed = S.mapSeed || 1;
    const a = (seed * 37) % 100;
    const b = (seed * 59) % 100;
    const c = (seed * 83) % 100;

    const bg = $("boardBg");
    bg.style.background =
      `radial-gradient(260px 200px at ${10+a}% ${18+b}%, rgba(33,199,196,.20), rgba(0,0,0,0) 60%),
       radial-gradient(300px 260px at ${55+c}% ${30+a}%, rgba(33,199,196,.16), rgba(0,0,0,0) 60%),
       radial-gradient(240px 240px at ${40+b}% ${78+c}%, rgba(0,0,0,.06), rgba(0,0,0,0) 62%),
       linear-gradient(180deg, rgba(255,255,255,.86), rgba(255,255,255,.74))`;

    if (S.theme === "dark"){
      bg.style.background =
        `radial-gradient(260px 200px at ${10+a}% ${18+b}%, rgba(33,199,196,.18), rgba(0,0,0,0) 60%),
         radial-gradient(300px 260px at ${55+c}% ${30+a}%, rgba(33,199,196,.12), rgba(0,0,0,0) 60%),
         radial-gradient(240px 240px at ${40+b}% ${78+c}%, rgba(0,0,0,.45), rgba(0,0,0,0) 62%),
         linear-gradient(180deg, rgba(10,33,38,.94), rgba(8,26,31,.94))`;
    }
  }

  /* =======================
     Toast
  ======================== */
  let toastTimer = null;
  function toast(msg){
    if (!msg) return;
    toastEl.textContent = msg;
    toastEl.classList.remove("hidden");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toastEl.classList.add("hidden"), 2600);
  }

  /* =======================
     Init UI from state
  ======================== */
  function init(){
    $("selLang").value = S.lang;
    $("selTheme").value = S.theme;
    $("selAi").value = S.ai;
    $("selTexture").value = S.texture;

    applyTheme();
    applyTexture();

    applyI18n();
    buildModes();
    buildSizes();
    buildGoals();
    syncPlayerInputs();
    refreshSettingsMeta();
    renderHomeSummary();
    updateContinue();

    // if state says inGame, we stay at home; user can Continue
    showPage("home");
  }

  init();

})();
</script>
</body>
</html>
