<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#22c7c7" />
  <!-- –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–¥—Å–∫–∞–∑–∞—Ç—å WebView –Ω–µ –∫—ç—à–∏—Ä–æ–≤–∞—Ç—å (–Ω–µ –≤—Å–µ–≥–¥–∞ –ø–æ–º–æ–≥–∞–µ—Ç –≤ Telegram, –ø–æ—ç—Ç–æ–º—É –≤–∞–∂–Ω–µ–µ ?v=... –≤ URL) -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Tic Tac Toe+</title>

  <style>
    :root{
      --teal-1:#35d3d2;
      --teal-2:#18bfbf;
      --teal-3:#10a8a8;

      --bg:#f4f7f7;
      --text:#0b1a22;
      --muted:#5e6b74;

      --card:#ffffff;
      --stroke: rgba(15, 35, 45, .10);
      --shadow: 0 16px 50px rgba(0,0,0,.10);

      --pill:#eef6f6;
      --pillText:#0b1a22;

      --btn:#18bfbf;
      --btnText:#ffffff;

      --btnGhost:#ffffff;
      --btnGhostText:#0b1a22;

      --cell:#ffffff;
      --cellStroke: rgba(0,0,0,.10);

      --safeTop: env(safe-area-inset-top, 0px);
      --safeBottom: env(safe-area-inset-bottom, 0px);

      --radiusXL: 28px;
      --radiusL: 20px;
      --radiusM: 16px;
      --radiusS: 12px;

      --maxW: 520px;
    }

    [data-theme="dark"]{
      --bg:#071b1f;
      --text:#eaf6f7;
      --muted:#a9c1c4;

      --card:#0d252b;
      --stroke: rgba(255,255,255,.12);
      --shadow: 0 18px 60px rgba(0,0,0,.35);

      --pill:#0b2b31;
      --pillText:#eaf6f7;

      --btn:#22c7c7;
      --btnText:#001115;

      --btnGhost:#0d252b;
      --btnGhostText:#eaf6f7;

      --cell:#0b2026;
      --cellStroke: rgba(255,255,255,.14);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      overflow-x:hidden;
    }

    /* —Ñ–æ–Ω/—Ç–µ–∫—Å—Ç—É—Ä—ã (—Ä–∞–Ω–¥–æ–º–Ω–æ) */
    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      opacity:.85;
      background:
        radial-gradient(800px 500px at 75% -10%, rgba(53,211,210,.35), rgba(53,211,210,0) 60%),
        radial-gradient(700px 500px at -10% 20%, rgba(24,191,191,.25), rgba(24,191,191,0) 60%),
        radial-gradient(900px 600px at 50% 110%, rgba(16,168,168,.15), rgba(16,168,168,0) 60%);
      z-index:-2;
    }

    .wrap{
      min-height:100%;
      padding: calc(18px + var(--safeTop)) 14px calc(18px + var(--safeBottom));
      display:flex;
      justify-content:center;
      align-items:center;
    }

    .app{
      width: min(var(--maxW), 100%);
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    .topbar{
      display:flex;
      gap:10px;
      justify-content:space-between;
      align-items:center;
    }

    .miniBadge{
      display:flex; gap:10px; align-items:center;
      padding:10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.45);
      border: 1px solid rgba(255,255,255,.45);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    [data-theme="dark"] .miniBadge{
      background: rgba(0,0,0,.25);
      border-color: rgba(255,255,255,.10);
    }
    .logo{
      width:36px;height:36px;border-radius:999px;
      background: linear-gradient(180deg,var(--teal-1),var(--teal-3));
      display:grid;place-items:center;
      color:white; font-weight:800;
      letter-spacing:.5px;
      user-select:none;
      flex:0 0 auto;
    }
    .miniActions{
      display:flex;gap:8px;align-items:center;
    }
    .iconBtn{
      width:40px;height:40px;border-radius:999px;
      border: 1px solid rgba(255,255,255,.45);
      background: rgba(255,255,255,.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:grid; place-items:center;
      cursor:pointer;
      user-select:none;
    }
    [data-theme="dark"] .iconBtn{
      border-color: rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
    }
    .iconBtn:active{ transform: scale(.98); }

    .hero{
      border-radius: var(--radiusXL);
      background: linear-gradient(180deg, var(--teal-1), var(--teal-3));
      color:white;
      padding:16px 16px 14px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .hero::after{
      content:"";
      position:absolute;
      width:220px;height:220px;border-radius:999px;
      right:-60px; top:-70px;
      background: rgba(255,255,255,.18);
    }
    .hero h1{
      margin:8px 0 6px;
      font-size: 28px;
      line-height: 1.1;
      letter-spacing: -0.3px;
    }
    .hero .sub{
      font-size: 14px;
      opacity:.95;
    }
    .hero .row{
      margin-top:12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }

    .card{
      border-radius: var(--radiusL);
      background: var(--card);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      padding:14px;
    }

    .titleRow{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
    }
    .titleRow h2{
      margin:0;
      font-size:18px;
      letter-spacing:-0.2px;
    }
    .muted{ color: var(--muted); font-size:13px; }

    .btn{
      border:none;
      border-radius: 999px;
      padding: 12px 16px;
      font-weight:700;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      min-height: 44px;
      white-space:nowrap;
    }
    .btnPrimary{
      background: var(--btn);
      color: var(--btnText);
      box-shadow: 0 10px 24px rgba(24,191,191,.25);
    }
    .btnGhost{
      background: var(--btnGhost);
      color: var(--btnGhostText);
      border: 1px solid var(--stroke);
    }
    .btn:active{ transform: translateY(1px); }

    .seg{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .chip{
      padding:10px 12px;
      border-radius:999px;
      border: 1px solid var(--stroke);
      background: var(--btnGhost);
      color: var(--btnGhostText);
      font-weight:700;
      cursor:pointer;
      user-select:none;
    }
    .chip[aria-pressed="true"]{
      border-color: rgba(24,191,191,.55);
      box-shadow: 0 10px 26px rgba(24,191,191,.18);
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 420px){
      .grid2{ grid-template-columns: 1fr; }
      .hero h1{ font-size: 24px; }
    }

    label{ font-size:12px; color: var(--muted); display:block; margin:6px 2px 6px; }
    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    select, input{
      width:100%;
      padding:12px 12px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: var(--card);
      color: var(--text);
      outline:none;
      min-height: 44px;
      font-size: 14px;
    }

    .saveBtnRow{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }

    /* –Ω–∏–∂–Ω–µ–µ –º–µ–Ω—é - —Ç–æ–ª—å–∫–æ –Ω–∞ Home/Settings */
    .bottomNav{
      position: sticky;
      bottom: calc(10px + var(--safeBottom));
      margin-top: 8px;
      border-radius: 24px;
      background: var(--card);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      padding:10px;
      display:flex;
      gap:10px;
      justify-content:space-between;
      align-items:center;
    }
    .navItem{
      flex:1;
      border-radius: 18px;
      padding:10px 12px;
      display:flex; align-items:center; justify-content:center;
      gap:10px;
      cursor:pointer;
      user-select:none;
      border:1px solid transparent;
      color: var(--muted);
      font-weight:800;
    }
    .navItem[aria-current="page"]{
      background: rgba(24,191,191,.10);
      border-color: rgba(24,191,191,.25);
      color: var(--text);
    }

    /* GAME */
    .gameWrap{
      width:min(var(--maxW), 100%);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .gameTop{
      border-radius: var(--radiusL);
      background: var(--card);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .gameTopRow{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
      flex-wrap:wrap;
    }
    .turnLine{
      font-size:16px;
      font-weight:900;
      letter-spacing:-0.2px;
    }
    .miniLine{
      margin-top:2px;
      font-size:13px;
      color: var(--muted);
      font-weight:700;
    }
    .gameBtns{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .btnSmall{
      padding:10px 12px;
      min-height: 40px;
      font-weight:900;
    }

    .boardCard{
      border-radius: var(--radiusL);
      background: var(--card);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      padding: 12px;
      overflow:hidden;
    }

    .board{
      display:grid;
      gap:10px;
      width:100%;
    }
    .cell{
      aspect-ratio: 1 / 1;
      border-radius: 14px;
      background: var(--cell);
      border: 1px solid var(--cellStroke);
      display:grid;
      place-items:center;
      font-weight: 1000;
      font-size: clamp(16px, 3.6vw, 28px);
      cursor:pointer;
      user-select:none;
      position:relative;
      overflow:hidden;
    }
    .cell::after{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(120px 120px at 30% 20%, rgba(24,191,191,.14), transparent 55%);
      opacity: var(--cellFx, 1);
      pointer-events:none;
    }
    [data-theme="dark"] .cell::after{
      background: radial-gradient(120px 120px at 30% 20%, rgba(24,191,191,.10), transparent 60%);
    }
    .cell:active{ transform: scale(.99); }

    .sym0{ color:#0b1a22; }
    .sym1{ color:#18bfbf; }
    .sym2{ color:#7c59ff; }
    .sym3{ color:#ff7a18; }

    [data-theme="dark"] .sym0{ color:#eaf6f7; }
    [data-theme="dark"] .sym1{ color:#22c7c7; }
    [data-theme="dark"] .sym2{ color:#b69bff; }
    [data-theme="dark"] .sym3{ color:#ffa25e; }

    .toast{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom: calc(16px + var(--safeBottom));
      background: rgba(0,0,0,.75);
      color: #fff;
      padding:10px 12px;
      border-radius: 999px;
      font-weight:800;
      font-size: 13px;
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index:9999;
    }
    .toast.show{
      opacity:1;
      transform:translateX(-50%) translateY(-6px);
    }

    details{
      border: 1px solid var(--stroke);
      border-radius: 16px;
      padding: 10px 12px;
      background: rgba(24,191,191,.05);
    }
    summary{
      cursor:pointer;
      font-weight:900;
      outline:none;
    }
    .rulesText{
      margin-top:8px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.5;
      font-weight:700;
    }

    .hidden{ display:none !important; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="app" id="app" data-theme="light">
      <!-- Header mini -->
      <div class="topbar" id="topbar">
        <div class="miniBadge">
          <div class="logo">TT</div>
          <div style="display:flex;flex-direction:column;gap:2px">
            <div style="font-weight:1000;letter-spacing:-0.2px" id="hdrTitle">Tic-Tac-Toe+</div>
            <div class="muted" id="hdrSub">v<span id="verOut"></span></div>
          </div>
        </div>
        <div class="miniActions">
          <button class="iconBtn" id="langBtn" title="Language">üåê</button>
          <button class="iconBtn" id="themeBtn" title="Theme">üåì</button>
        </div>
      </div>

      <!-- HOME SCREEN -->
      <div id="screenHome">
        <div class="hero" id="hero">
          <div class="sub" id="heroSmall">‚Äî</div>
          <h1 id="heroTitle">‚Äî</h1>
          <div class="sub" id="heroMeta">‚Äî</div>

          <div class="row">
            <button class="btn btnPrimary" id="btnStart">‚ñ∂ <span id="startTxt">‚Äî</span></button>
            <button class="btn btnGhost" id="btnContinue">‚èµ <span id="contTxt">‚Äî</span></button>
          </div>
        </div>
      </div>

      <!-- SETTINGS SCREEN -->
      <div id="screenSettings" class="hidden">
        <div class="card">
          <div class="titleRow">
            <div>
              <h2 id="setTitle">‚Äî</h2>
              <div class="muted" id="setSubtitle">‚Äî</div>
            </div>
          </div>

          <div class="grid2" style="margin-top:10px">
            <div class="field">
              <label id="lblLang">‚Äî</label>
              <select id="selLang">
                <option value="ru">–†—É—Å—Å–∫–∏–π</option>
                <option value="en">English</option>
                <option value="uz">O‚Äòzbek (lotin)</option>
              </select>
            </div>

            <div class="field">
              <label id="lblTheme">‚Äî</label>
              <select id="selTheme">
                <option value="light">Light</option>
                <option value="dark">Dark</option>
              </select>
            </div>
          </div>

          <div style="margin-top:10px">
            <label id="lblMode">‚Äî</label>
            <div class="seg" id="modeSeg"></div>
          </div>

          <div class="grid2" style="margin-top:10px">
            <div class="field">
              <label id="lblSize">‚Äî</label>
              <select id="selSize"></select>
            </div>

            <div class="field">
              <label id="lblGoal">‚Äî</label>
              <select id="selGoal"></select>
            </div>
          </div>

          <div class="grid2" style="margin-top:10px" id="aiBlock">
            <div class="field">
              <label id="lblAi">‚Äî</label>
              <select id="selAi">
                <option value="easy">Easy</option>
                <option value="medium">Medium</option>
                <option value="expert">Expert</option>
              </select>
            </div>
            <div class="field">
              <label id="lblTexture">‚Äî</label>
              <select id="selTexture">
                <option value="auto">Auto</option>
                <option value="aqua">Aqua</option>
                <option value="map">Map</option>
                <option value="paper">Paper</option>
              </select>
            </div>
          </div>

          <div class="grid2" style="margin-top:10px">
            <div class="field">
              <label id="lblP1">‚Äî</label>
              <input id="inpP1" placeholder="Alex" />
            </div>
            <div class="field">
              <label id="lblP2">‚Äî</label>
              <input id="inpP2" placeholder="Player 2" />
            </div>
          </div>

          <div class="grid2" style="margin-top:10px" id="p34Block">
            <div class="field">
              <label id="lblP3">‚Äî</label>
              <input id="inpP3" placeholder="Player 3" />
            </div>
            <div class="field">
              <label id="lblP4">‚Äî</label>
              <input id="inpP4" placeholder="Player 4" />
            </div>
          </div>

          <div style="margin-top:10px">
            <details>
              <summary id="rulesTitle">‚Äî</summary>
              <div class="rulesText" id="rulesBody">‚Äî</div>
            </details>
          </div>

          <div class="saveBtnRow">
            <button class="btn btnPrimary" id="btnSave">üíæ <span id="saveTxt">‚Äî</span></button>
            <button class="btn btnGhost" id="btnReset">‚Ü∫ <span id="resetTxt">‚Äî</span></button>
          </div>
        </div>
      </div>

      <!-- GAME SCREEN -->
      <div id="screenGame" class="hidden">
        <div class="gameWrap">
          <div class="gameTop">
            <div class="gameTopRow">
              <div>
                <div class="turnLine" id="turnLine">‚Äî</div>
                <div class="miniLine" id="miniLine">‚Äî</div>
              </div>

              <div class="gameBtns">
                <div style="min-width:160px">
                  <select id="selGoalInGame" title="Goal"></select>
                </div>
                <button class="btn btnGhost btnSmall" id="btnUndo"><span id="undoTxt">‚Äî</span></button>
                <button class="btn btnGhost btnSmall" id="btnRestart"><span id="restartTxt">‚Äî</span></button>
                <button class="btn btnPrimary btnSmall" id="btnMenu"><span id="menuTxt">‚Äî</span></button>
              </div>
            </div>
          </div>

          <div class="boardCard" id="boardCard">
            <div class="board" id="board"></div>
          </div>
        </div>
      </div>

      <!-- bottom nav (only home/settings) -->
      <div class="bottomNav" id="bottomNav">
        <div class="navItem" id="navHome" aria-current="page">‚åÇ <span id="navHomeTxt">‚Äî</span></div>
        <div class="navItem" id="navSettings">‚öô <span id="navSetTxt">‚Äî</span></div>
      </div>

    </div>
  </div>

  <div class="toast" id="toast">‚Äî</div>

<script>
(() => {
  const APP_VERSION = "2025.12.22-1"; // –º–µ–Ω—è–π —ç—Ç–æ –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∞–ø–¥–µ–π—Ç–µ + –º–µ–Ω—è–π ?v=... –≤ Telegram
  const LS_KEY = "ttt_plus_state_v3";

  // ===== i18n =====
  const I18N = {
    ru: {
      heroSmall: "–ì–ª–∞–≤–Ω–∞—è",
      heroTitle: "–ö—Ä–µ—Å—Ç–∏–∫–∏-–Ω–æ–ª–∏–∫–∏+",
      start: "–ù–∞—á–∞—Ç—å –∏–≥—Ä—É",
      cont: "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å",
      contNA: "–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –∏–≥—Ä—ã",
      setTitle: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
      setSubtitle: "–Ø–∑—ã–∫ ¬∑ –¢–µ–º–∞ ¬∑ –†–µ–∂–∏–º ¬∑ –ü–æ–ª–µ ¬∑ –¶–µ–ª—å ¬∑ –ò–º–µ–Ω–∞",
      lang: "–Ø–∑—ã–∫",
      theme: "–¢–µ–º–∞",
      mode: "–†–µ–∂–∏–º",
      size: "–†–∞–∑–º–µ—Ä –ø–æ–ª—è",
      goal: "–¶–µ–ª—å (–≤ —Ä—è–¥)",
      ai: "–°–ª–æ–∂–Ω–æ—Å—Ç—å –ò–ò",
      texture: "–¢–µ–∫—Å—Ç—É—Ä–∞",
      p1: "–ò–≥—Ä–æ–∫ 1 (X)",
      p2: "–ò–≥—Ä–æ–∫ 2 (O)",
      p3: "–ò–≥—Ä–æ–∫ 3 (‚ñ≤)",
      p4: "–ò–≥—Ä–æ–∫ 4 (‚ñ†)",
      save: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
      reset: "–°–±—Ä–æ—Å–∏—Ç—å –≤—Å—ë",
      rulesTitle: "–ü—Ä–∞–≤–∏–ª–∞",
      rulesBody:
        "–¶–µ–ª—å ‚Äî —Å–æ–±—Ä–∞—Ç—å –∑–∞–¥–∞–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–º–≤–æ–ª–æ–≤ –ø–æ–¥—Ä—è–¥ (–ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏, –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ –∏–ª–∏ –¥–∏–∞–≥–æ–Ω–∞–ª–∏). " +
        "–†–∞–∑–º–µ—Ä –ø–æ–ª—è –¥–æ 10√ó10. –¶–µ–ª—å (–≤ —Ä—è–¥) –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å ‚â§ —Ä–∞–∑–º–µ—Ä—É –ø–æ–ª—è. " +
        "–í —Ä–µ–∂–∏–º–µ —Å –ò–ò –±–æ—Ç –∏–≥—Ä–∞–µ—Ç –∑–∞ O. –í —Ä–µ–∂–∏–º–∞—Ö –Ω–∞ 3‚Äì4 –∏–≥—Ä–æ–∫–∞ —Ö–æ–¥—ã –∏–¥—É—Ç –ø–æ –∫—Ä—É–≥—É. " +
        "–í–æ –≤—Ä–µ–º—è –∏–≥—Ä—ã –º–æ–∂–Ω–æ –º–µ–Ω—è—Ç—å —Ü–µ–ª—å (–≤ —Ä—è–¥) ‚Äî –æ–Ω–∞ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è —Å—Ä–∞–∑—É.",
      navHome: "–ì–ª–∞–≤–Ω–∞—è",
      navSet: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",

      mode_pvp: "–ò–≥—Ä–æ–∫ vs –ò–≥—Ä–æ–∫",
      mode_ai: "–ò–≥—Ä–æ–∫ vs –ò–ò",
      mode_3: "3 –∏–≥—Ä–æ–∫–∞",
      mode_4: "4 –∏–≥—Ä–æ–∫–∞",

      easy: "–õ—ë–≥–∫–∏–π",
      medium: "–°—Ä–µ–¥–Ω–∏–π",
      expert: "–≠–∫—Å–ø–µ—Ä—Ç",

      turn: "–•–æ–¥–∏—Ç",
      goalInline: "–¶–µ–ª—å (–≤ —Ä—è–¥)",
      undo: "–ù–∞–∑–∞–¥",
      restart: "–ó–∞–Ω–æ–≤–æ",
      menu: "–í—ã–π—Ç–∏",

      win: "–ü–æ–±–µ–¥–∏–ª",
      draw: "–ù–∏—á—å—è",
      saved: "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ",
      loaded: "–ó–∞–≥—Ä—É–∂–µ–Ω–æ",
      cleared: "–°–±—Ä–æ—à–µ–Ω–æ",
      needStart: "–°–Ω–∞—á–∞–ª–∞ –Ω–∞–∂–º–∏ ¬´–ù–∞—á–∞—Ç—å –∏–≥—Ä—É¬ª",
    },
    en: {
      heroSmall: "Home",
      heroTitle: "Tic-Tac-Toe+",
      start: "Start game",
      cont: "Continue",
      contNA: "No saved game",
      setTitle: "Settings",
      setSubtitle: "Language ¬∑ Theme ¬∑ Mode ¬∑ Board ¬∑ Goal ¬∑ Names",
      lang: "Language",
      theme: "Theme",
      mode: "Mode",
      size: "Board size",
      goal: "Goal (in a row)",
      ai: "AI difficulty",
      texture: "Texture",
      p1: "Player 1 (X)",
      p2: "Player 2 (O)",
      p3: "Player 3 (‚ñ≤)",
      p4: "Player 4 (‚ñ†)",
      save: "Save",
      reset: "Reset all",
      rulesTitle: "Rules",
      rulesBody:
        "Goal ‚Äî build the chosen number in a row (horizontal, vertical or diagonal). " +
        "Board size up to 10√ó10. Goal must be ‚â§ board size. " +
        "In AI mode the bot plays as O. In 3‚Äì4 players turns go in a loop. " +
        "During the game you can change the goal ‚Äî it applies instantly.",
      navHome: "Home",
      navSet: "Settings",

      mode_pvp: "Player vs Player",
      mode_ai: "Player vs AI",
      mode_3: "3 players",
      mode_4: "4 players",

      easy: "Easy",
      medium: "Medium",
      expert: "Expert",

      turn: "Turn",
      goalInline: "Goal",
      undo: "Undo",
      restart: "Restart",
      menu: "Exit",

      win: "Winner",
      draw: "Draw",
      saved: "Saved",
      loaded: "Loaded",
      cleared: "Cleared",
      needStart: "Press ‚ÄúStart game‚Äù first",
    },
    uz: {
      heroSmall: "Bosh sahifa",
      heroTitle: "X-O+",
      start: "O‚Äòyinni boshlash",
      cont: "Davom ettirish",
      contNA: "Saqlangan o‚Äòyin yo‚Äòq",
      setTitle: "Sozlamalar",
      setSubtitle: "Til ¬∑ Mavzu ¬∑ Rejim ¬∑ Maydon ¬∑ Maqsad ¬∑ Ismlar",
      lang: "Til",
      theme: "Mavzu",
      mode: "Rejim",
      size: "Maydon o‚Äòlchami",
      goal: "Maqsad (qator)",
      ai: "AI darajasi",
      texture: "Tekstura",
      p1: "1-o‚Äòyinchi (X)",
      p2: "2-o‚Äòyinchi (O)",
      p3: "3-o‚Äòyinchi (‚ñ≤)",
      p4: "4-o‚Äòyinchi (‚ñ†)",
      save: "Saqlash",
      reset: "Hammasini tozalash",
      rulesTitle: "Qoidalar",
      rulesBody:
        "Maqsad ‚Äî tanlangan son bo‚Äòyicha ketma-ket belgilarni yig‚Äòish (gorizontal, vertikal yoki diagonal). " +
        "Maydon 10√ó10 gacha. Maqsad (qator) maydon o‚Äòlchamidan katta bo‚Äòlishi mumkin emas. " +
        "AI rejimida bot O bilan o‚Äòynaydi. 3‚Äì4 o‚Äòyinchida navbat aylana bo‚Äòyicha. " +
        "O‚Äòyin paytida maqsadni o‚Äòzgartirish mumkin ‚Äî darhol ishlaydi.",
      navHome: "Bosh",
      navSet: "Sozlama",

      mode_pvp: "O‚Äòyinchi vs O‚Äòyinchi",
      mode_ai: "O‚Äòyinchi vs AI",
      mode_3: "3 o‚Äòyinchi",
      mode_4: "4 o‚Äòyinchi",

      easy: "Oson",
      medium: "O‚Äòrtacha",
      expert: "Ekspert",

      turn: "Navbat",
      goalInline: "Maqsad",
      undo: "Orqaga",
      restart: "Qayta",
      menu: "Chiqish",

      win: "G‚Äòolib",
      draw: "Durang",
      saved: "Saqlanndi",
      loaded: "Yuklandi",
      cleared: "Tozalandi",
      needStart: "Avval ‚ÄúO‚Äòyinni boshlash‚Äùni bosing",
    }
  };

  // ===== state =====
  const defaultState = () => ({
    version: APP_VERSION,
    lang: "ru",
    theme: "light",
    texture: "auto",
    mode: "pvp", // pvp | ai | p3 | p4
    size: 8,     // 3..10
    goal: 5,     // 3..size
    ai: "expert",
    names: ["Alex", "Player 2", "Player 3", "Player 4"],
    // game
    inGame: false,
    board: [],
    turn: 0,
    moves: [],
    winner: null,
    finished: false,
    lastScreen: "home"
  });

  let S = loadState() ?? defaultState();
  if (!S.version) S.version = APP_VERSION;

  // ===== DOM =====
  const $ = (id) => document.getElementById(id);
  const app = $("app");

  const screenHome = $("screenHome");
  const screenSettings = $("screenSettings");
  const screenGame = $("screenGame");
  const bottomNav = $("bottomNav");
  const topbar = $("topbar");

  const modeSeg = $("modeSeg");
  const selSize = $("selSize");
  const selGoal = $("selGoal");
  const selGoalInGame = $("selGoalInGame");
  const aiBlock = $("aiBlock");
  const p34Block = $("p34Block");

  const selLang = $("selLang");
  const selTheme = $("selTheme");
  const selAi = $("selAi");
  const selTexture = $("selTexture");

  const inpP1 = $("inpP1");
  const inpP2 = $("inpP2");
  const inpP3 = $("inpP3");
  const inpP4 = $("inpP4");

  const boardEl = $("board");
  const verOut = $("verOut");

  // buttons
  const btnStart = $("btnStart");
  const btnContinue = $("btnContinue");
  const btnSave = $("btnSave");
  const btnReset = $("btnReset");

  const btnUndo = $("btnUndo");
  const btnRestart = $("btnRestart");
  const btnMenu = $("btnMenu");

  const navHome = $("navHome");
  const navSettings = $("navSettings");

  const themeBtn = $("themeBtn");
  const langBtn = $("langBtn");

  // labels outputs
  const out = {
    heroSmall: $("heroSmall"),
    heroTitle: $("heroTitle"),
    heroMeta: $("heroMeta"),
    startTxt: $("startTxt"),
    contTxt: $("contTxt"),
    setTitle: $("setTitle"),
    setSubtitle: $("setSubtitle"),
    lblLang: $("lblLang"),
    lblTheme: $("lblTheme"),
    lblMode: $("lblMode"),
    lblSize: $("lblSize"),
    lblGoal: $("lblGoal"),
    lblAi: $("lblAi"),
    lblTexture: $("lblTexture"),
    lblP1: $("lblP1"),
    lblP2: $("lblP2"),
    lblP3: $("lblP3"),
    lblP4: $("lblP4"),
    saveTxt: $("saveTxt"),
    resetTxt: $("resetTxt"),
    rulesTitle: $("rulesTitle"),
    rulesBody: $("rulesBody"),
    navHomeTxt: $("navHomeTxt"),
    navSetTxt: $("navSetTxt"),
    turnLine: $("turnLine"),
    miniLine: $("miniLine"),
    undoTxt: $("undoTxt"),
    restartTxt: $("restartTxt"),
    menuTxt: $("menuTxt"),
    hdrSub: $("hdrSub"),
  };

  // toast
  const toast = $("toast");
  let toastTimer = null;
  const showToast = (msg) => {
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.classList.remove("show"), 1400);
  };

  // ===== init selectors =====
  verOut.textContent = APP_VERSION;

  function clampGoal(size, goal){
    const g = Math.max(3, Math.min(size, goal|0));
    return g;
  }

  function buildSizes(){
    selSize.innerHTML = "";
    for (let n=3; n<=10; n++){
      const opt = document.createElement("option");
      opt.value = String(n);
      opt.textContent = `${n}√ó${n}`;
      selSize.appendChild(opt);
    }
  }
  function buildGoals(size, selectEl){
    selectEl.innerHTML = "";
    for (let g=3; g<=size; g++){
      const opt = document.createElement("option");
      opt.value = String(g);
      opt.textContent = String(g);
      selectEl.appendChild(opt);
    }
  }

  buildSizes();

  // ===== themes / texture =====
  function applyTheme(){
    app.setAttribute("data-theme", S.theme);
    selTheme.value = S.theme;
  }

  function applyTexture(){
    const t = (S.texture === "auto") ? pickAutoTexture() : S.texture;
    // –º–µ–Ω—è–µ–º —á—É—Ç—å —ç—Ñ—Ñ–µ–∫—Ç –Ω–∞ –∫–ª–µ—Ç–∫–∞—Ö + —Ñ–æ–Ω boardCard
    const card = $("boardCard");
    card.style.background = "var(--card)";
    app.style.setProperty("--cellFx", "1");

    if (t === "map"){
      // –ø—Å–µ–≤–¥–æ ‚Äú–∫–∞—Ä—Ç–∞‚Äù (–±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö –∫–∞—Ä—Ç–∏–Ω–æ–∫): –Ω–∞–±–æ—Ä –ø—è—Ç–µ–Ω
      card.style.background = `
        radial-gradient(260px 180px at 20% 30%, rgba(24,191,191,.12), transparent 60%),
        radial-gradient(220px 160px at 70% 20%, rgba(16,168,168,.10), transparent 62%),
        radial-gradient(240px 200px at 60% 80%, rgba(53,211,210,.10), transparent 60%),
        var(--card)`;
      app.style.setProperty("--cellFx", ".8");
    } else if (t === "paper"){
      card.style.background = `
        linear-gradient(0deg, rgba(0,0,0,.03), rgba(0,0,0,0)),
        repeating-linear-gradient(90deg, rgba(0,0,0,.02) 0 2px, transparent 2px 10px),
        var(--card)`;
      app.style.setProperty("--cellFx", ".55");
    } else if (t === "aqua"){
      card.style.background = `
        radial-gradient(320px 220px at 20% 25%, rgba(24,191,191,.12), transparent 60%),
        radial-gradient(260px 220px at 80% 70%, rgba(53,211,210,.10), transparent 60%),
        var(--card)`;
      app.style.setProperty("--cellFx", "1");
    }

    selTexture.value = S.texture;
  }

  function pickAutoTexture(){
    const arr = ["aqua","map","paper"];
    // –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ –ø–æ –≤–µ—Ä—Å–∏–∏
    const seed = hash(APP_VERSION) % arr.length;
    return arr[seed];
  }

  function hash(str){
    let h = 2166136261;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h>>>0);
  }

  // ===== i18n apply =====
  function T(){ return I18N[S.lang] ?? I18N.ru; }

  function applyI18n(){
    const t = T();

    out.heroSmall.textContent = t.heroSmall;
    out.heroTitle.textContent = t.heroTitle;

    out.startTxt.textContent = t.start;
    out.contTxt.textContent = t.cont;

    out.setTitle.textContent = t.setTitle;
    out.setSubtitle.textContent = t.setSubtitle;

    out.lblLang.textContent = t.lang;
    out.lblTheme.textContent = t.theme;
    out.lblMode.textContent = t.mode;
    out.lblSize.textContent = t.size;
    out.lblGoal.textContent = t.goal;
    out.lblAi.textContent = t.ai;
    out.lblTexture.textContent = t.texture;

    out.lblP1.textContent = t.p1;
    out.lblP2.textContent = t.p2;
    out.lblP3.textContent = t.p3;
    out.lblP4.textContent = t.p4;

    out.saveTxt.textContent = t.save;
    out.resetTxt.textContent = t.reset;

    out.rulesTitle.textContent = t.rulesTitle;
    out.rulesBody.textContent = t.rulesBody;

    out.navHomeTxt.textContent = t.navHome;
    out.navSetTxt.textContent = t.navSet;

    out.undoTxt.textContent = t.undo;
    out.restartTxt.textContent = t.restart;
    out.menuTxt.textContent = t.menu;

    // mode chips text
    renderModeSeg();

    // AI select labels
    const aiOpt = selAi.querySelectorAll("option");
    aiOpt.forEach(o => {
      if (o.value === "easy") o.textContent = t.easy;
      if (o.value === "medium") o.textContent = t.medium;
      if (o.value === "expert") o.textContent = t.expert;
    });

    // header sub
    out.hdrSub.textContent = `v${APP_VERSION}`;
  }

  function modeLabel(mode){
    const t = T();
    if (mode === "pvp") return t.mode_pvp;
    if (mode === "ai") return t.mode_ai;
    if (mode === "p3") return t.mode_3;
    if (mode === "p4") return t.mode_4;
    return mode;
  }

  function renderModeSeg(){
    const t = T();
    const items = [
      {k:"pvp", label:t.mode_pvp},
      {k:"ai",  label:t.mode_ai},
      {k:"p3",  label:t.mode_3},
      {k:"p4",  label:t.mode_4},
    ];
    modeSeg.innerHTML = "";
    for (const it of items){
      const b = document.createElement("button");
      b.className = "chip";
      b.type = "button";
      b.textContent = it.label;
      b.setAttribute("aria-pressed", String(S.mode === it.k));
      b.addEventListener("click", () => {
        S.mode = it.k;
        if (S.mode === "ai"){
          // –∞–≤—Ç–æ–ø–æ–¥—Å—Ç–∞–≤–∏–º –∏–º—è –±–æ—Ç–∞
          S.names[1] = botName();
        }
        enforceModeUI();
        renderModeSeg();
        saveState();
      });
      modeSeg.appendChild(b);
    }
  }

  function botName(){
    const t = T();
    // –ª–æ–∫–∞–ª–∏–∑—É–µ–º ‚ÄúBot‚Äù
    if (S.lang === "ru") return "–ë–æ—Ç";
    if (S.lang === "uz") return "Bot";
    return "Bot";
  }

  // ===== enforce UI rules =====
  function enforceModeUI(){
    const isAI = S.mode === "ai";
    aiBlock.classList.toggle("hidden", !isAI);

    // –∏–º–µ–Ω–∞
    inpP1.value = S.names[0] ?? "Alex";
    inpP2.value = (isAI ? botName() : (S.names[1] ?? "Player 2"));
    inpP2.disabled = isAI;

    const show34 = (S.mode === "p3" || S.mode === "p4");
    p34Block.classList.toggle("hidden", !show34);

    inpP3.value = S.names[2] ?? "Player 3";
    inpP4.value = S.names[3] ?? "Player 4";
    inpP4.parentElement.classList.toggle("hidden", S.mode !== "p4");

    // sizes/goals
    selSize.value = String(S.size);
    buildGoals(S.size, selGoal);
    S.goal = clampGoal(S.size, S.goal);
    selGoal.value = String(S.goal);

    buildGoals(S.size, selGoalInGame);
    selGoalInGame.value = String(S.goal);

    // ai
    selAi.value = S.ai;
    selLang.value = S.lang;
    selTheme.value = S.theme;
    selTexture.value = S.texture;

    updateHeroMeta();
    updateContinueBtn();
  }

  function updateHeroMeta(){
    const t = T();
    const players = getPlayers();
    const namesStr = players.map(p => `${p.name} (${p.sym})`).join(", ");
    out.heroMeta.textContent = `${modeLabel(S.mode)} ¬∑ ${S.size}√ó${S.size} ¬∑ ${t.goalInline}: ${S.goal}\n${namesStr}`;
    // –º–∞–ª–µ–Ω—å–∫–∞—è —Å—Ç—Ä–æ–∫–∞ —Å–≤–µ—Ä—Ö—É
    out.heroSmall.textContent = t.heroSmall;
    out.heroTitle.textContent = t.heroTitle;
  }

  function updateContinueBtn(){
    const t = T();
    const has = hasSavedGame();
    btnContinue.disabled = !has;
    out.contTxt.textContent = has ? t.cont : t.contNA;
    btnContinue.style.opacity = has ? "1" : ".55";
  }

  // ===== navigation (screens) =====
  function showScreen(which){
    S.lastScreen = which;
    const isGame = which === "game";

    screenHome.classList.toggle("hidden", which !== "home");
    screenSettings.classList.toggle("hidden", which !== "settings");
    screenGame.classList.toggle("hidden", which !== "game");

    // bottom nav only on home/settings
    bottomNav.classList.toggle("hidden", isGame);

    navHome.setAttribute("aria-current", which === "home" ? "page" : "false");
    navSettings.setAttribute("aria-current", which === "settings" ? "page" : "false");
    navHome.classList.toggle("hidden", isGame);
    navSettings.classList.toggle("hidden", isGame);

    // topbar always visible (–∫–∞–∫ –º–∏–Ω–∏-—Ö–µ–¥–µ—Ä)
    saveState();
  }

  navHome.addEventListener("click", () => showScreen("home"));
  navSettings.addEventListener("click", () => showScreen("settings"));

  // quick buttons
  themeBtn.addEventListener("click", () => {
    S.theme = (S.theme === "light") ? "dark" : "light";
    applyTheme();
    saveState();
  });

  langBtn.addEventListener("click", () => {
    const order = ["ru","en","uz"];
    const idx = order.indexOf(S.lang);
    S.lang = order[(idx+1) % order.length];
    if (S.mode === "ai") S.names[1] = botName();
    applyI18n();
    enforceModeUI();
    if (S.inGame) renderGameTop();
    saveState();
  });

  // settings inputs
  selLang.addEventListener("change", () => {
    S.lang = selLang.value;
    if (S.mode === "ai") S.names[1] = botName();
    applyI18n();
    enforceModeUI();
    if (S.inGame) renderGameTop();
    saveState();
  });

  selTheme.addEventListener("change", () => {
    S.theme = selTheme.value;
    applyTheme();
    saveState();
  });

  selTexture.addEventListener("change", () => {
    S.texture = selTexture.value;
    applyTexture();
    saveState();
  });

  selSize.addEventListener("change", () => {
    S.size = parseInt(selSize.value,10);
    S.goal = clampGoal(S.size, S.goal);
    buildGoals(S.size, selGoal);
    selGoal.value = String(S.goal);
    buildGoals(S.size, selGoalInGame);
    selGoalInGame.value = String(S.goal);
    enforceModeUI();
    saveState();
  });

  selGoal.addEventListener("change", () => {
    S.goal = clampGoal(S.size, parseInt(selGoal.value,10));
    selGoalInGame.value = String(S.goal);
    updateHeroMeta();
    saveState();
  });

  selAi.addEventListener("change", () => {
    S.ai = selAi.value;
    saveState();
  });

  // names
  function pullNamesFromInputs(){
    S.names[0] = (inpP1.value || "Alex").trim();
    if (S.mode === "ai") {
      S.names[1] = botName();
    } else {
      S.names[1] = (inpP2.value || "Player 2").trim();
    }
    S.names[2] = (inpP3.value || "Player 3").trim();
    S.names[3] = (inpP4.value || "Player 4").trim();
  }
  [inpP1,inpP2,inpP3,inpP4].forEach(el => el.addEventListener("input", () => {
    pullNamesFromInputs();
    updateHeroMeta();
    saveState();
  }));

  // save/reset
  btnSave.addEventListener("click", () => {
    pullNamesFromInputs();
    enforceModeUI();
    saveState();
    showToast(T().saved);
  });

  btnReset.addEventListener("click", () => {
    const keepLang = S.lang;
    const keepTheme = S.theme;
    S = defaultState();
    S.lang = keepLang;
    S.theme = keepTheme;
    applyTheme();
    buildSizes();
    applyI18n();
    enforceModeUI();
    applyTexture();
    showScreen("home");
    saveState(true);
    showToast(T().cleared);
  });

  // ===== game logic =====
  const SYMBOLS = ["X","O","‚ñ≤","‚ñ†"];

  function playersCount(){
    if (S.mode === "pvp") return 2;
    if (S.mode === "ai") return 2;
    if (S.mode === "p3") return 3;
    if (S.mode === "p4") return 4;
    return 2;
  }

  function getPlayers(){
    const n = playersCount();
    const arr = [];
    for (let i=0;i<n;i++){
      const name = (S.names[i] || `P${i+1}`).trim();
      arr.push({ idx:i, name, sym: SYMBOLS[i] });
    }
    if (S.mode === "ai"){
      arr[1].name = botName();
    }
    return arr;
  }

  function newGame(){
    S.inGame = true;
    S.finished = false;
    S.winner = null;
    S.turn = 0;
    S.moves = [];
    S.board = Array.from({length:S.size}, () => Array(S.size).fill(-1));
    saveState();
    applyTexture();
    renderBoard();
    renderGameTop();
    showScreen("game");

    // –µ—Å–ª–∏ AI –∏ –±–æ—Ç —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º ‚Äî (—É –Ω–∞—Å —á–µ–ª–æ–≤–µ–∫ X –≤—Å–µ–≥–¥–∞ –ø–µ—Ä–≤—ã–π)
  }

  function hasSavedGame(){
    // –µ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ, –µ—Å–ª–∏ inGame –∏ –µ—Å—Ç—å board + moves
    return !!(S && S.board && Array.isArray(S.board) && S.board.length && Array.isArray(S.moves) && S.moves.length >= 0 && S.inGame);
  }

  btnStart.addEventListener("click", () => {
    // —Å—Ç–∞—Ä—Ç –≤—Å–µ–≥–¥–∞ —Å –Ω—É–ª—è
    newGame();
  });

  btnContinue.addEventListener("click", () => {
    if (!hasSavedGame()){
      showToast(T().needStart);
      return;
    }
    // –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ—Ä–µ–Ω–¥–µ—Ä
    S.inGame = true;
    applyTexture();
    renderBoard();
    renderGameTop();
    showScreen("game");
    showToast(T().loaded);
  });

  btnUndo.addEventListener("click", () => undoMove());
  btnRestart.addEventListener("click", () => {
    newGame();
  });
  btnMenu.addEventListener("click", () => {
    // –≤—ã–π—Ç–∏ –∏–∑ –∏–≥—Ä—ã (–Ω–µ —É–¥–∞–ª—è—è –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–∞—Å—Ç—Ä–æ–π–∫–∏)
    S.inGame = false;
    S.finished = false;
    S.winner = null;
    S.moves = [];
    S.board = [];
    saveState();
    updateContinueBtn();
    updateHeroMeta();
    showScreen("home");
  });

  selGoalInGame.addEventListener("change", () => {
    S.goal = clampGoal(S.size, parseInt(selGoalInGame.value,10));
    selGoal.value = String(S.goal);
    renderGameTop();
    saveState();
  });

  function renderGameTop(){
    const t = T();
    const players = getPlayers();
    const p = players[S.turn % players.length];

    out.turnLine.textContent = `${t.turn}: ${p.name} (${p.sym})`;
    out.miniLine.textContent = `${S.size}√ó${S.size} ¬∑ ${t.goalInline}: ${S.goal}`;

    // ensure goal selector
    buildGoals(S.size, selGoalInGame);
    selGoalInGame.value = String(S.goal);

    // translate buttons (fix your issue: Undo/Restart stuck in EN)
    out.undoTxt.textContent = t.undo;
    out.restartTxt.textContent = t.restart;
    out.menuTxt.textContent = t.menu;
  }

  function renderBoard(){
    boardEl.innerHTML = "";
    const n = S.size;
    boardEl.style.gridTemplateColumns = `repeat(${n}, 1fr)`;

    const players = getPlayers();
    for (let r=0;r<n;r++){
      for (let c=0;c<n;c++){
        const v = S.board?.[r]?.[c] ?? -1;
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.r = String(r);
        cell.dataset.c = String(c);
        if (v >= 0){
          cell.textContent = SYMBOLS[v];
          cell.classList.add(`sym${v}`);
        } else {
          cell.textContent = "";
        }

        cell.addEventListener("click", () => {
          if (!S.inGame || S.finished) return;

          // AI mode: —á–µ–ª–æ–≤–µ–∫ –∏–≥—Ä–∞–µ—Ç —Ç–æ–ª—å–∫–æ –∑–∞ 0
          if (S.mode === "ai" && (S.turn % 2) === 1) return;

          placeMove(r,c);
        });

        boardEl.appendChild(cell);
      }
    }
  }

  function placeMove(r,c){
    if (S.finished) return;
    if (S.board[r][c] !== -1) return;

    const pIdx = S.turn % playersCount();
    S.board[r][c] = pIdx;
    S.moves.push({r,c,p:pIdx});

    // check win
    const win = checkWinner(S.board, S.goal);
    if (win.winner >= 0){
      S.finished = true;
      S.winner = win.winner;
      saveState();
      renderBoard();
      renderGameTop();
      showToast(`${T().win}: ${getPlayers()[S.winner].name}`);
      return;
    }
    if (isFull(S.board)){
      S.finished = true;
      S.winner = -1;
      saveState();
      renderBoard();
      renderGameTop();
      showToast(T().draw);
      return;
    }

    S.turn++;
    saveState();
    renderBoard();
    renderGameTop();

    // AI move
    if (S.mode === "ai" && (S.turn % 2) === 1 && !S.finished){
      setTimeout(() => {
        const move = aiPickMove(S.board, S.goal, S.ai);
        if (move) placeMove(move.r, move.c);
      }, 120);
    }
  }

  function undoMove(){
    if (!S.moves.length || S.finished) {
      if (S.finished) {
        // –ø–æ–∑–≤–æ–ª–∏–º undo –ø–æ—Å–ª–µ –ø–æ–±–µ–¥—ã: –ø—Ä–æ—Å—Ç–æ —Å–Ω–∏–º–µ–º —Ñ–ª–∞–≥ –∏ –æ—Ç–∫–∞—Ç–∏–º 1 —Ö–æ–¥ (–∏, –µ—Å–ª–∏ AI, 2 —Ö–æ–¥–∞)
        // (—á—Ç–æ–±—ã –±—ã–ª–æ —É–¥–æ–±–Ω–æ)
      }
    }

    const isAI = S.mode === "ai";

    function popOne(){
      const m = S.moves.pop();
      if (!m) return false;
      S.board[m.r][m.c] = -1;
      S.turn = Math.max(0, S.turn - 1);
      return true;
    }

    // –µ—Å–ª–∏ –±—ã–ª —Ñ–∏–Ω–∞–ª ‚Äî —Å–Ω–∏–º–∞–µ–º
    S.finished = false;
    S.winner = null;

    // –æ–±—ã—á–Ω—ã–π undo
    if (!popOne()){
      renderBoard(); renderGameTop(); saveState(); return;
    }

    // –µ—Å–ª–∏ AI ‚Äî –æ—Ç–∫–∞—Ç—ã–≤–∞–µ–º –µ—â—ë –æ–¥–∏–Ω —Ö–æ–¥ –±–æ—Ç–∞ (—á—Ç–æ–±—ã —Ä–µ–∞–ª—å–Ω–æ –≤–µ—Ä–Ω—É—Ç—å —Ö–æ–¥ —á–µ–ª–æ–≤–µ–∫—É)
    if (isAI && S.moves.length){
      // –ø–æ—Å–ª–µ –æ—Ç–∫–∞—Ç–∞ –º–æ–≥ –æ–∫–∞–∑–∞—Ç—å—Å—è —Ö–æ–¥ –±–æ—Ç–∞ ‚Äî –æ—Ç–∫–∞—Ç—ã–≤–∞–µ–º –µ—â–µ
      if ((S.turn % 2) === 1){
        popOne();
      }
    }

    saveState();
    renderBoard();
    renderGameTop();
  }

  function isFull(board){
    for (let r=0;r<board.length;r++){
      for (let c=0;c<board.length;c++){
        if (board[r][c] === -1) return false;
      }
    }
    return true;
  }

  // winner check (any symbol >= goal in row)
  function checkWinner(board, goal){
    const n = board.length;
    const dirs = [
      {dr:0, dc:1},
      {dr:1, dc:0},
      {dr:1, dc:1},
      {dr:1, dc:-1},
    ];
    for (let r=0;r<n;r++){
      for (let c=0;c<n;c++){
        const p = board[r][c];
        if (p < 0) continue;
        for (const d of dirs){
          let k=1;
          let rr=r+d.dr, cc=c+d.dc;
          while (rr>=0 && rr<n && cc>=0 && cc<n && board[rr][cc]===p){
            k++; rr+=d.dr; cc+=d.dc;
            if (k>=goal) return { winner:p };
          }
        }
      }
    }
    return { winner:-1 };
  }

  // ===== AI =====
  function aiPickMove(board, goal, level){
    const n = board.length;
    const empties = [];
    for (let r=0;r<n;r++){
      for (let c=0;c<n;c++){
        if (board[r][c] === -1) empties.push({r,c});
      }
    }
    if (!empties.length) return null;

    if (level === "easy"){
      return empties[Math.floor(Math.random()*empties.length)];
    }

    // candidate moves: near existing marks (faster on big boards)
    const cand = candidateMoves(board);
    const moves = cand.length ? cand : empties;

    // 1) immediate win
    for (const m of moves){
      const b2 = cloneBoard(board);
      b2[m.r][m.c] = 1; // bot is O (index 1)
      if (checkWinner(b2, goal).winner === 1) return m;
    }
    // 2) block immediate human win
    for (const m of moves){
      const b2 = cloneBoard(board);
      b2[m.r][m.c] = 0; // human X
      if (checkWinner(b2, goal).winner === 0) return m;
    }

    if (level === "medium"){
      // heuristic best score
      let best = moves[0], bestScore = -1e9;
      for (const m of moves){
        const sc = heuristicScore(board, m, goal);
        if (sc > bestScore){ bestScore=sc; best=m; }
      }
      return best;
    }

    // expert: limited minimax on candidates
    const maxDepth = (n <= 5 ? 4 : (n <= 8 ? 3 : 2));
    const limit = Math.min(22, moves.length); // cap
    const shuffled = moves.slice().sort(() => Math.random()-0.5).slice(0, limit);

    let best = shuffled[0], bestVal = -1e9;
    for (const m of shuffled){
      const b2 = cloneBoard(board);
      b2[m.r][m.c] = 1;
      const val = minimax(b2, goal, maxDepth-1, false, -1e9, 1e9);
      if (val > bestVal){ bestVal = val; best = m; }
    }
    return best;
  }

  function cloneBoard(b){ return b.map(row => row.slice()); }

  function candidateMoves(board){
    const n = board.length;
    const set = new Map();
    const add = (r,c) => {
      const k = r+"_"+c;
      if (!set.has(k)) set.set(k,{r,c});
    };
    for (let r=0;r<n;r++){
      for (let c=0;c<n;c++){
        if (board[r][c] !== -1){
          for (let dr=-1; dr<=1; dr++){
            for (let dc=-1; dc<=1; dc++){
              if (dr===0 && dc===0) continue;
              const rr=r+dr, cc=c+dc;
              if (rr>=0 && rr<n && cc>=0 && cc<n && board[rr][cc]===-1) add(rr,cc);
            }
          }
        }
      }
    }
    return Array.from(set.values());
  }

  function minimax(board, goal, depth, isMax, alpha, beta){
    const w = checkWinner(board, goal).winner;
    if (w === 1) return 100000 + depth;   // bot wins
    if (w === 0) return -100000 - depth;  // human wins
    if (depth <= 0 || isFull(board)) return evalBoard(board, goal);

    const moves = candidateMoves(board);
    const n = board.length;
    const actualMoves = moves.length ? moves : allEmpty(board);

    if (isMax){
      let best = -1e9;
      for (const m of actualMoves){
        board[m.r][m.c] = 1;
        const val = minimax(board, goal, depth-1, false, alpha, beta);
        board[m.r][m.c] = -1;
        best = Math.max(best, val);
        alpha = Math.max(alpha, best);
        if (beta <= alpha) break;
      }
      return best;
    } else {
      let best = 1e9;
      for (const m of actualMoves){
        board[m.r][m.c] = 0;
        const val = minimax(board, goal, depth-1, true, alpha, beta);
        board[m.r][m.c] = -1;
        best = Math.min(best, val);
        beta = Math.min(beta, best);
        if (beta <= alpha) break;
      }
      return best;
    }
  }

  function allEmpty(board){
    const n=board.length, arr=[];
    for (let r=0;r<n;r++) for (let c=0;c<n;c++) if (board[r][c]===-1) arr.push({r,c});
    return arr;
  }

  function evalBoard(board, goal){
    // simple line potential scoring
    return linePotential(board, 1, goal) - linePotential(board, 0, goal);
  }

  function heuristicScore(board, move, goal){
    const b2 = cloneBoard(board);
    b2[move.r][move.c] = 1;
    return evalBoard(b2, goal) + centerBonus(board.length, move);
  }

  function centerBonus(n, m){
    const mid = (n-1)/2;
    const d = Math.abs(m.r-mid) + Math.abs(m.c-mid);
    return -d;
  }

  function linePotential(board, who, goal){
    const n = board.length;
    const dirs = [
      {dr:0, dc:1},
      {dr:1, dc:0},
      {dr:1, dc:1},
      {dr:1, dc:-1},
    ];
    let score = 0;
    for (let r=0;r<n;r++){
      for (let c=0;c<n;c++){
        for (const d of dirs){
          // window length=goal
          let cnt=0, blocked=false;
          for (let k=0;k<goal;k++){
            const rr=r+d.dr*k, cc=c+d.dc*k;
            if (rr<0 || rr>=n || cc<0 || cc>=n){ blocked=true; break; }
            const v = board[rr][cc];
            if (v === -1) continue;
            if (v === who) cnt++;
            else { blocked=true; break; }
          }
          if (!blocked && cnt>0){
            score += Math.pow(3, cnt);
          }
        }
      }
    }
    return score;
  }

  // ===== persistence =====
  function saveState(force=false){
    try{
      const toSave = JSON.parse(JSON.stringify(S));
      // –µ—Å–ª–∏ force ‚Äî —É–¥–∞–ª–∏–º –∏–≥—Ä—É
      if (force){
        toSave.inGame = false;
        toSave.board = [];
        toSave.moves = [];
        toSave.finished = false;
        toSave.winner = null;
      }
      localStorage.setItem(LS_KEY, JSON.stringify(toSave));
    }catch(e){}
  }
  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return null;
      const obj = JSON.parse(raw);
      // –º–∏–≥—Ä–∞—Ü–∏—è –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è
      if (!obj.size) return null;
      obj.goal = clampGoal(obj.size, obj.goal ?? 3);
      return obj;
    }catch(e){
      return null;
    }
  }

  // ===== first render =====
  function boot(){
    applyTheme();
    applyI18n();

    // init selects from state
    selLang.value = S.lang;
    selTheme.value = S.theme;
    selAi.value = S.ai;
    selTexture.value = S.texture;

    // sizes/goals
    selSize.value = String(S.size);
    buildGoals(S.size, selGoal);
    selGoal.value = String(S.goal);
    buildGoals(S.size, selGoalInGame);
    selGoalInGame.value = String(S.goal);

    enforceModeUI();
    applyTexture();

    // if previously in game, keep continue
    updateContinueBtn();

    // default screen
    if (S.lastScreen === "settings") showScreen("settings");
    else showScreen("home");
  }

  boot();
})();
</script>
</body>
</html>